% Copyright (c) 2015  The PARI Group
%
% This file is part of the PARI/GP documentation
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU General Public License
\chapter{$L$-functions}

\section{Accessors}

\fun{long}{is_linit}{GEN data}

\fun{GEN}{ldata_get_an}{GEN ldata}

\fun{GEN}{ldata_get_dual}{GEN ldata}

\fun{long}{ldata_isreal}{GEN ldata}

\fun{GEN}{ldata_get_gammavec}{GEN ldata}

\fun{long}{ldata_get_degree}{GEN ldata}

\fun{long}{ldata_get_k}{GEN ldata}

\fun{GEN}{ldata_get_conductor}{GEN ldata}

\fun{GEN}{ldata_get_rootno}{GEN ldata}

\fun{GEN}{ldata_get_residue}{GEN ldata}

\fun{GEN}{ldata_vecan}{GEN ldata, long L, long prec}

\fun{long}{ldata_get_type}{GEN ldata}

\fun{long}{linit_get_type}{GEN linit}

\fun{GEN}{linit_get_ldata}{GEN linit}

\fun{GEN}{linit_get_tech}{GEN linit}

\fun{GEN}{lfun_get_domain}{GEN tech}

\fun{GEN}{lfun_get_dom}{GEN tech}

\fun{long}{lfun_get_bitprec}{GEN tech}

\fun{GEN}{lfun_get_factgammavec}{GEN tech}

\fun{GEN}{lfun_get_step}{GEN tech}

\fun{GEN}{lfun_get_pol}{GEN tech}

\fun{GEN}{lfun_get_Residue}{GEN tech}

\fun{GEN}{lfun_get_k2}{GEN tech}

\fun{GEN}{lfun_get_w2}{GEN tech}

\fun{GEN}{lfun_get_expot}{GEN tech}

\fun{long}{lfun_get_der}{GEN tech}

\fun{long}{lfun_get_bitprec}{GEN tech}

\fun{long}{lfunisvgaell}{GEN Vga, long flag}

\fun{GEN}{lfunprod_get_fact}{GEN tech}

\fun{GEN}{theta_get_an}{GEN tdata}

\fun{GEN}{theta_get_K}{GEN tdata}

\fun{GEN}{theta_get_R}{GEN tdata}

\fun{long}{theta_get_bitprec}{GEN tdata}

\fun{long}{theta_get_m}{GEN tdata}

\fun{GEN}{theta_get_tdom}{GEN tdata}

\fun{GEN}{theta_get_sqrtN}{GEN tdata}

\section{Conversions and constructors}

\fun{GEN}{lfunmisc_to_ldata}{GEN ldata}

\fun{GEN}{lfunmisc_to_ldata_shallow}{GEN ldata}

\fun{GEN}{lfunrtopoles}{GEN r}

\fun{int}{sdomain_isincl}{GEN dom, GEN dom0}

\section{Variants of GP functions}

\fun{GEN}{lfun}{GEN ldata, GEN s, long bitprec}

\fun{GEN}{lfuninit}{GEN ldata, GEN dom, long der, long bitprec}

\fun{GEN}{lfuninit_make}{long t, GEN ldata, GEN molin, GEN domain}

\fun{GEN}{lfunlambda}{GEN ldata, GEN s, long bitprec}

\fun{long}{lfunthetacost}{GEN ldata, GEN tdom, long m, long bitprec}:
 \kbd{lfunthetacost0} when the first argument is known to be an \kbd{Ldata}.

\fun{GEN}{lfunthetacheckinit}{GEN data, GEN tinf, long m, long bitprec}

\fun{GEN}{lfunrootno}{GEN data, long bitprec}

\fun{GEN}{lfunzetakinit}{GEN pol, GEN dom, long der, long flag, long bitprec}

\fun{GEN}{lfunellmfpeters}{GEN E, long bitprec}

\fun{GEN}{ellanalyticrank}{GEN E, long prec} DEPRECATED.

\fun{GEN}{ellL1}{GEN E, long prec} DEPRECATED.

\section{Inverse Mellin transforms of Gamma products}

\fun{GEN}{gammamellininv}{GEN Vga, GEN s, long m, long bitprec}

\fun{GEN}{gammamellininvinit}{GEN Vga, long m, long bitprec}

\fun{GEN}{gammamellininvrt}{GEN K, GEN s, long bitprec}

\fun{double}{dbllambertW0}{double a}

\fun{double}{dbllambertW_1}{double a}

\fun{double}{dbllemma526}{double a, double b, double c, long B}

\fun{double}{dblcoro526}{double a, double c, long B}

\newpage

\chapter{Modular symbols}

\fun{void}{checkms}{GEN W} raise an exception if $W$ is not an \var{ms}
structure from \kbd{msinit}.

\fun{void}{checkmspadic}{GEN W} raise an exception if $W$ is not an
\var{mspadic} structure from \kbd{mspadicinit}.

Variants of \kbd{mfnumcusps} :

\fun{ulong}{mfnumcuspsu}{ulong n}

\fun{GEN}{mfnumcusps_fact}{GEN fa} where \kbd{fa} is \kbd{factor}$(n)$.

\fun{ulong}{mfnumcuspsu_fact}{GEN fa} where \kbd{fa} is \kbd{factoru}$(n)$.

\chapter{Modular forms}

\newpage

\chapter{Plots}

A \tet{PARI_plot} canvas is a record of dimensions, with the following fields:
\bprog
  long width;  /* window width */
  long height; /* window height */
  long hunit;  /* length of horizontal 'ticks' */
  long vunit;  /* length of vertical 'ticks' */
  long fwidth; /* font width */
  long fheight;/* font height */
  void (*draw)(PARI_plot *T, GEN w, GEN x, GEN y);
@eprog\noindent The \kbd{draw} method performs the actual drawing of
a \typ{VECSMALL} w (rectwindow indices); $x$ and $y$ are \typ{VECSMALL}s
of the same length and rectwindow $w[i]$ is drawn with its upper left
corner at offset $(x[i],y[i])$. No plot engine is available in \kbd{libpari}
by default, since thie would introduce a dependency on extra graphical
libraries. See the files \kbd{src/graph/plot*} for basic implementations of
various plot engines: \kbd{plotsvg} is particularly simple (\kbd{draw} is a
1-liner).

\fun{void}{pari_set_plot_engine}{void (*T)(PARI_plot *)} installs the
graphical engine $T$ and initializes the graphical subsystem. No routine in
this chapter will work without this initialization.

\fun{void}{pari_kill_plot_engine}{void} closes the graphical subsystem and
frees the ressources it occupies.

\subsec{Highlevel function}
Those functions plot $f(E,x)$ for $x\in [a,b]$, using $n$ regularly spaced
points (by default).

\fun{GEN}{ploth}{void *E, GEN(*f)(void*,GEN), GEN a, GEN b, long flags,long
n, long prec} draw physically.

\fun{GEN}{plotrecth}{void *E, GEN(*f)(void*,GEN), long w, GEN a,GEN b, ulong
flags,long n, long prec} draw in rectwindow $w$.

\fun{GEN}{psploth}{void *E, GEN(*f)(void*,GEN), GEN a, GEN b, long flags,
long n, long prec} draw to a PostScript file.

\subsec{Function }

\fun{void}{plotbox}{long ne, GEN gx2, GEN gy2}

\fun{void}{plotclip}{long rect}

\fun{void}{plotcolor}{long ne, long color}

\fun{void}{plotcopy}{long source, long dest, GEN xoff, GEN yoff, long flag}

\fun{GEN}{plotcursor}{long ne}

\fun{void}{plotdraw}{GEN list, long flag}

\fun{GEN}{plothraw}{GEN listx, GEN listy, long flag}

\fun{GEN}{plothsizes}{long flag}

\fun{void}{plotinit}{long ne, GEN x, GEN y, long flag}

\fun{void}{plotkill}{long ne}

\fun{void}{plotline}{long ne, GEN x2, GEN y2}

\fun{void}{plotlines}{long ne, GEN listx, GEN listy, long flag}

\fun{void}{plotlinetype}{long ne, long t}

\fun{void}{plotmove}{long ne, GEN x, GEN y}

\fun{void}{plotpoints}{long ne, GEN listx, GEN listy}

\fun{void}{plotpointsize}{long ne, GEN size}

\fun{void}{plotpointtype}{long ne, long t}

\fun{void}{plotrbox}{long ne, GEN x2, GEN y2}

\fun{GEN}{plotrecthraw}{long ne, GEN data, long flags}

\fun{void}{plotrline}{long ne, GEN x2, GEN y2}

\fun{void}{plotrmove}{long ne, GEN x, GEN y}

\fun{void}{plotrpoint}{long ne, GEN x, GEN y}

\fun{void}{plotscale}{long ne, GEN x1, GEN x2, GEN y1, GEN y2}

\fun{void}{plotstring}{long ne, char *x, long dir}

\fun{void}{psdraw}{GEN list, long flag}

\fun{GEN}{psplothraw}{GEN listx, GEN listy, long flag}

\subsec{Dump rectwindows to a PostScript or SVG file}

$w,x,y$ are three \typ{VECSMALL}s indicating the rectwindows to dump, at
which offsets. If $T$ is \kbd{NULL}, rescale with respect to the installed
graphic engine dimensions; else with respect to $T$.

\fun{char*}{rect2ps}{GEN w, GEN x, GEN y, PARI_plot *T}

\fun{char*}{rect2ps_i}{GEN w, GEN x, GEN y, PARI_plot *T, int plotps}
if \kbd{plotps} is $0$, as above; else private version used to implement
the \kbd{plotps} graphic engine (do not rescale, rotate to portrait
orientation).

\fun{char*}{rect2svg}{GEN w, GEN x, GEN y, PARI_plot *T}

\subsec{Technical functions exported for convenience}

\fun{void}{pari_plot_by_file}{const char *env, const char *suf, const char *img}
backend used by the \kbd{plotps} and \kbd{plotsvg} graphic engines.

\fun{void}{colorname_to_rgb}{const char *s, int *r, int *g, int *b} convert
an \kbd{X11} colorname to RGB values.

\fun{void}{color_to_rgb}{GEN c, int *r, int *g, int *b} convert a pari color
(\typ{VECSMALL} RGB triple or \typ{STR} name) ro RGV values.

\newpage
