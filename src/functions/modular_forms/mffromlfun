Function: mffromlfun
Section: modular_forms
C-Name: mffromlfun
Prototype: Gp
Help: mffromlfun(L): L being an L-function representing a self-dual modular
 form, return [mf,f,v] where f is the form, mf is a modular form space
 containing it and v is mftobasis(mf,f).
Doc: Let $L$ being an $L$-function in any of the \kbd{lfun} formats representing
 a self-dual modular form (for instance an eigenform). If $L$ has
 rational coefficients, return $[\var{mf},f,v]$ where $f$ is the form,
 \var{mf} is a modular form space containing it and $v$ is
 \kbd{mftobasis(mf,f)}.

 \bprog
 ? L = lfuncreate(x^2+1); L[2..7]
 %1 = [0, [0, 1], 1, 4, 1, 0]
 ? lfunan(L,10)
 %2 = [1, 1, 0, 1, 2, 0, 0, 1, 1, 2]
 ? -lfun(L,0)
 %3 = 0.25000000000000000000000000000000000000
 ? [mf,F,v] = mffromlfun(L); mfparams(mf)
 %4 = [4, 1, -4, 4]
 ? mfcoefs(F,10)
 %5 = [1/4, 1, 1, 0, 1, 2, 0, 0, 1, 1, 2]
 @eprog

 If $L$ has inexact complex coefficients, return only the modular form space
 \var{mf}, which probably contains $f$. At this point one can for instance
 compute an eigenbasis for \var{mf} and check whether one of the attached
 $L$-function is reasonably close to $L$. In the example, we cheat by
 producing the $L$ function from an eigenform in a known space, but the
 function does not use this information:
 \bprog
 ? mf = mfinit([32,6,Mod(5,32)],0);
 ? [poldegree(K) | K<-mffields(mf)]
 %2 = [19] \\ one orbit, [Q(F) : Q(chi)] = 19
 ? L = lfunmf(mf)[1][1]; \\ one of the 19 L-functions attached to F
 ? lfunan(L,3)
 %4 = [1, 5.654... - 0.1812...*I, -7.876... - 19.02...*I]
 ? MF = mffromlfun(L); mfparams(MF)
 %5 = [32, 6, Mod(5, 32), 1]
 ? vL = concat(lfunmf(MF)); \\ L functions for all cuspidal eigenforms
 ? an = lfunan(L,10);
 ? for (i = 1, #vL, if (normlp(lfunan(vL[i],10) - an, oo) < 1e-10, print(i)));
 5
 @eprog
