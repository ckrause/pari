Function: limitnum
Section: sums
C-Name: limitnum0
Prototype: GDGp
Help: limitnum(expr,{alpha=1}): numerical limit of sequence expr
 using Lagrange-Zagier extrapolation; assume u(n) ~ sum a_i n^(-alpha*i).
Doc: Lagrange-Zagier numerical extrapolation of \var{expr}, corresponding to
 a sequence $u_n$, either given by a closure \kbd{n->u(n)}. I.e., assuming
 that $u_n$ tends to a finite limit $\ell$, try to determine $\ell$.

 The routine assume that $u_n$ has an asymptotic expansion in $n^{-\alpha}$ :
 $$u_n = \ell + \sum_{i\geq 1} a_i n^{-i\alpha}$$
 for some $a_i$. It is purely numerical and heuristic, thus may or may not
 work on your examples. The expression will be evaluated for $n = 1, 2,
 \dots, N$ for an $N = O(B)$ at a bit accuracy bounded by $1.612 B$.

 \bprog
 ? limitnum(n -> n*sin(1/n))
 %1 = 1.0000000000000000000000000000000000000

 ? limitnum(n -> (1+1/n)^n) - exp(1)
 %2 = 0.E-37

 ? limitnum(n -> 2^(4*n+1)*(n!)^4 / (2*n)! /(2*n+1)! ) - Pi
 %3 = 0.E -37

 ? \p5000
 ? limitnum(n -> (1+1/n)^n) - exp(1)
 time = 1,444 ms.
 %4 = 0.E-5008
 ? limitnum(n -> (1+1/n)^n,, 0) - exp(1)
 time = 204 ms.
 %5 = 0.E-5008 \\ still perfect, 6 times faster
 @eprog\noindent
 Aternatively, $u_n$ may be given by a vector of values:
 it must be long and precise enough for the extrapolation
 to make sense. Let $B$ be the current \kbd{realbitprecision}, the vector
 length must be at least $1.102 B$ and the values computed with bit accuracy
 $1.612 B$.

 The preferred format is thus a closure, although it becomes inconvenient
 when $u_n$ cannot be directly computed in time polynomial in $\log n$,
 for instance if it is defined as a sum or by induction. In that case,
 passing a vector of values is the best option:
 \bprog
 ? limitnum(vector(10,n,(1+1/n)^n))
  ***                 ^--------------------
  *** limitnum: non-existent component in limitnum: index < 43
 \\ at this accuracy, we must have at least 43 values
 ? limitnum(vector(43,n,(1+1/n)^n)) - exp(1)
 %6 = 0.E-37

 ? v = vector(43);
 ? s = 0; for(i=1,#v, s += 1/i; v[i]= s - log(i));
 ? limitnum(v) - Euler
 %9 = -1.7... E-16

 ? v = vector(43);
 \\ ~ 128 bit * 1.612
 ? localbitprec(207);\
   s = 0; for(i=1,#v, s += 1/i; v[i]= s - log(i));
 ? limitnum(v) - Euler
 %12 = 0.E-38
 @eprog

 The expression is evaluated for $n = 1, 2, \dots, N$
 for an $N = O(B)$ if the current bit accuracy is $B$. If it is not defined
 for one of these values, translate or rescale accordingly:
 \bprog
 ? limitnum(n->log(1-1/n))  \\ can't evaluate at n = 1 !
  ***   at top-level: limitnum(n->log(1-1/n))
  ***                 ^-----------------------
  ***   in function limitnum: log(1-1/n)
  ***                         ^----------
  *** log: domain error in log: argument = 0
 ? limitnum(n->-log(1-1/(2*n)))
 %13 = 4.79... E-67
 @eprog

 \synt{limitnum}{void *E, GEN (*u)(void *,GEN,long), GEN alpha, long prec}, where \kbd{u(E, n, prec)} must return $u(n)$ in precision \kbd{prec}.
 Also available is
 \fun{GEN}{limitnum0}{GEN u, GEN alpha, long prec}, where $u$
 must be a vector of sufficient length as above.
