/* Copyright (C) 2000  The PARI group.

This file is part of the PARI/GP package.

PARI/GP is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation. It is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY WHATSOEVER.

Check the License for details. You should have received a copy of it, along
with the package; see the file 'COPYING'. If not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */

/*******************************************************************/
/*                                                                 */
/*                      KUMMER EXTENSIONS                          */
/*                                                                 */
/*******************************************************************/
#include "pari.h"
#include "paripriv.h"

typedef struct {
  GEN R; /* nf.pol */
  GEN x; /* tau ( Mod(x, R) ) */
  GEN zk;/* action of tau on nf.zk (as t_MAT) */
} tau_s;

typedef struct {
  GEN polnf, invexpoteta1, powg;
  tau_s *tau;
  long m;
} toK_s;

typedef struct {
  GEN R; /* ZX, compositum(P,Q) */
  GEN p; /* QX, Mod(p,R) root of P */
  GEN q; /* QX, Mod(q,R) root of Q */
  long k; /* Q[X]/R generated by q + k p */
  GEN rev;
} compo_s;

static long
prank(GEN cyc, long ell)
{
  long i, l = lg(cyc);
  for (i=1; i < l; i++)
    if (umodiu(gel(cyc,i),ell)) break;
  return i-1;
}

/* increment y, which runs through [0,d-1]^(k-1). Return 0 when done. */
static int
increment(GEN y, long k, long d)
{
  long i = k, j;
  do
  {
    if (--i == 0) return 0;
    y[i]++;
  } while (y[i] >= d);
  for (j = i+1; j < k; j++) y[j] = 0;
  return 1;
}

static int
ok_congruence(GEN X, ulong ell, long lW, GEN vecMsup)
{
  long i, l;
  l = lg(X);
  for (i=lW; i<l; i++)
    if (X[i] == 0) return 0;
  if (lW >= l && zv_equal0(X)) return 0;
  l = lg(vecMsup);
  for (i=1; i<l; i++)
    if (zv_equal0(Flm_Flc_mul(gel(vecMsup,i),X, ell))) return 0;
  return 1;
}

static int
ok_sign(GEN X, GEN msign, GEN arch)
{
  return zv_equal(Flm_Flc_mul(msign, X, 2), arch);
}

/* REDUCTION MOD ell-TH POWERS */

/* make be integral by multiplying by t in (Q^*)^ell */
static GEN
reduce_mod_Qell(GEN bnfz, GEN be, GEN gell)
{
  GEN c;
  be = nf_to_scalar_or_basis(bnfz, be);
  be = Q_primitive_part(be, &c);
  if (c)
  {
    GEN d, fa = factor(c);
    gel(fa,2) = FpC_red(gel(fa,2), gell);
    d = factorback(fa);
    be = typ(be) == t_INT? mulii(be,d): ZC_Z_mul(be, d);
  }
  return be;
}

/* return q, q^n r = x, v_pr(r) < n for all pr. Insist q is a genuine n-th
 * root (i.e r = 1) if strict != 0. */
static GEN
idealsqrtn(GEN nf, GEN x, GEN gn, int strict)
{
  long i, l, n = itos(gn);
  GEN fa, q, Ex, Pr;

  fa = idealfactor(nf, x);
  Pr = gel(fa,1); l = lg(Pr);
  Ex = gel(fa,2); q = NULL;
  for (i=1; i<l; i++)
  {
    long ex = itos(gel(Ex,i));
    GEN e = stoi(ex / n);
    if (strict && ex % n) pari_err_SQRTN("idealsqrtn", fa);
    if (q) q = idealmulpowprime(nf, q, gel(Pr,i), e);
    else   q = idealpow(nf, gel(Pr,i), e);
  }
  return q? q: gen_1;
}

static GEN
reducebeta(GEN bnfz, GEN b, GEN ell)
{
  GEN y, cb, nf = bnf_get_nf(bnfz);

  if (DEBUGLEVEL>1) err_printf("reducing beta = %Ps\n",b);
  b = reduce_mod_Qell(nf, b, ell);
  /* reduce l-th root */
  y = idealsqrtn(nf, b, ell, 0); /* (b) = y^ell I, I integral */
  if (typ(y) == t_MAT && !is_pm1(gcoeff(y,1,1)))
  {
    GEN T = idealred(nf, mkvec2(y, gen_1)), t = gel(T,2);
    /* (t)*T[1] = y, T[1] integral and small */
    if (gcmp(idealnorm(nf,t), gen_1) > 0)
      b = nfmul(nf, b, nfpow(nf, t, negi(ell)));
  }
  if (DEBUGLEVEL>1) err_printf("beta reduced via ell-th root = %Ps\n",b);
  b = Q_primitive_part(b, &cb);
  if (cb)
  {
    y = nfroots(nf, gsub(monomial(gen_1, itou(ell), fetch_var_higher()),
                         basistoalg(nf,b)));
    delete_var();
  }
  if (cb && lg(y) != 1) b = gen_1;
  else
  { /* log. embeddings of fu^ell */
    GEN fu = bnf_get_fu_nocheck(bnfz), logfu = bnf_get_logfu(bnfz);
    GEN elllogfu = RgM_Rg_mul(real_i(logfu), ell);
    long prec = nf_get_prec(nf);
    for (;;)
    {
      GEN emb, z = get_arch_real(nf, b, &emb, prec);
      if (z)
      {
        GEN ex = RgM_Babai(elllogfu, z);
        if (ex)
        {
          y = nffactorback(nf, fu, RgC_Rg_mul(ex,ell));
          b = nfdiv(nf, b, y); break;
        }
      }
      prec = precdbl(prec);
      if (DEBUGLEVEL) pari_warn(warnprec,"reducebeta",prec);
      nf = nfnewprec_shallow(nf,prec);
    }
  }
  if (cb) b = gmul(b, cb);
  if (DEBUGLEVEL>1) err_printf("beta LLL-reduced mod U^l = %Ps\n",b);
  return b;
}

/* FIXME: remove */
static GEN
tauofalg(GEN x, tau_s *tau) {
  long tx = typ(x);
  if (tx == t_POLMOD) { x = gel(x,2); tx = typ(x); }
  if (tx == t_POL) x = RgX_RgXQ_eval(x, tau->x, tau->R);
  return mkpolmod(x, tau->R);
}

struct rnfkummer
{
  GEN bnfz, u, vecC, Q, vecW;
  ulong g, ell;
  long rc;
  compo_s COMPO;
  tau_s tau;
  toK_s T;
};

/* set kum->tau; compute Gal(K(\zeta_l)/K) */
static void
get_tau(struct rnfkummer *kum)
{ /* compute action of tau: q^g + kp */
  compo_s *C = &kum->COMPO;
  GEN U = RgX_add(RgXQ_powu(C->q, kum->g, C->R), RgX_muls(C->p, C->k));
  kum->tau.x  = RgX_RgXQ_eval(C->rev, U, C->R);
  kum->tau.R  = C->R;
  kum->tau.zk = nfgaloismatrix(bnf_get_nf(kum->bnfz), kum->tau.x);
}

static GEN tauoffamat(GEN x, tau_s *tau);

static GEN
tauofelt(GEN x, tau_s *tau)
{
  switch(typ(x))
  {
    case t_COL: return RgM_RgC_mul(tau->zk, x);
    case t_MAT: return tauoffamat(x, tau);
    default: return tauofalg(x, tau);
  }
}
static GEN
tauofvec(GEN x, tau_s *tau)
{
  long i, l;
  GEN y = cgetg_copy(x, &l);
  for (i=1; i<l; i++) gel(y,i) = tauofelt(gel(x,i), tau);
  return y;
}
/* [x, tau(x), ..., tau^(m-1)(x)] */
static GEN
powtau(GEN x, long m, tau_s *tau)
{
  GEN y = cgetg(m+1, t_VEC);
  long i;
  gel(y,1) = x;
  for (i=2; i<=m; i++) gel(y,i) = tauofelt(gel(y,i-1), tau);
  return y;
}
/* x^lambda */
static GEN
lambdaofelt(GEN x, toK_s *T)
{
  tau_s *tau = T->tau;
  long i, m = T->m;
  GEN y = trivial_fact(), powg = T->powg; /* powg[i] = g^i */
  for (i=1; i<m; i++)
  {
    y = famat_mulpows_shallow(y, x, uel(powg,m-i+1));
    x = tauofelt(x, tau);
  }
  return famat_mul_shallow(y, x);
}
static GEN
lambdaofvec(GEN x, toK_s *T)
{
  long i, l;
  GEN y = cgetg_copy(x, &l);
  for (i=1; i<l; i++) gel(y,i) = lambdaofelt(gel(x,i), T);
  return y;
}

static GEN
tauoffamat(GEN x, tau_s *tau)
{
  return mkmat2(tauofvec(gel(x,1), tau), gel(x,2));
}

static GEN
tauofideal(GEN id, tau_s *tau)
{
  return ZM_hnfmodid(RgM_mul(tau->zk, id), gcoeff(id, 1,1));
}

static int
isprimeidealconj(GEN P, GEN Q, tau_s *tau)
{
  GEN p = pr_get_p(P);
  GEN x = pr_get_gen(P);
  if (!equalii(p, pr_get_p(Q))
   || pr_get_e(P) != pr_get_e(Q)
   || pr_get_f(P) != pr_get_f(Q)) return 0;
  if (ZV_equal(x, pr_get_gen(Q))) return 1;
  for(;;)
  {
    if (ZC_prdvd(x,Q)) return 1;
    x = FpC_red(tauofelt(x, tau), p);
    if (ZC_prdvd(x,P)) return 0;
  }
}

static int
isconjinprimelist(GEN S, GEN pr, tau_s *tau)
{
  long i, l;

  if (!tau) return 0;
  l = lg(S);
  for (i=1; i<l; i++)
    if (isprimeidealconj(gel(S,i),pr,tau)) return 1;
  return 0;
}

/* assume x in basistoalg form */
static GEN
downtoK(toK_s *T, GEN x)
{
  long degKz = lg(T->invexpoteta1) - 1;
  GEN y = gmul(T->invexpoteta1, Rg_to_RgC(lift_shallow(x), degKz));
  return gmodulo(gtopolyrev(y,varn(T->polnf)), T->polnf);
}

static GEN
no_sol(long all, long i)
{
  if (!all) pari_err_BUG(stack_sprintf("kummer [bug%ld]", i));
  return cgetg(1,t_VEC);
}

static GEN
get_gell(GEN bnr, GEN subgp, long all)
{
  GEN gell;
  if (all && all != -1) return utoipos(labs(all));
  if (!subgp) return ZV_prod(bnr_get_cyc(bnr));
  gell = det(subgp);
  if (typ(gell) != t_INT) pari_err_TYPE("rnfkummer",gell);
  return gell;
}

typedef struct {
  GEN Sm, Sml1, Sml2, Sl, ESml2;
} primlist;

static int
build_list_Hecke(primlist *L, GEN nfz, GEN fa, GEN gothf, long ell, tau_s *tau)
{
  GEN listpr, listex, pr, factell;
  long vp, i, l, degKz = nf_get_degree(nfz);

  if (!fa) fa = idealfactor(nfz, gothf);
  listpr = gel(fa,1);
  listex = gel(fa,2); l = lg(listpr);
  L->Sm  = vectrunc_init(l);
  L->Sml1= vectrunc_init(l);
  L->Sml2= vectrunc_init(l);
  L->Sl  = vectrunc_init(l+degKz);
  L->ESml2=vecsmalltrunc_init(l);
  for (i=1; i<l; i++)
  {
    pr = gel(listpr,i);
    vp = itos(gel(listex,i));
    if (!equaliu(pr_get_p(pr), ell))
    {
      if (vp != 1) return 1;
      if (!isconjinprimelist(L->Sm,pr,tau)) vectrunc_append(L->Sm,pr);
    }
    else
    {
      long e = pr_get_e(pr), vd = (vp-1)*(ell-1)-ell*e;
      if (vd > 0) return 4;
      if (vd==0)
      {
        if (!isconjinprimelist(L->Sml1,pr,tau)) vectrunc_append(L->Sml1, pr);
      }
      else
      {
        if (vp==1) return 2;
        if (!isconjinprimelist(L->Sml2,pr,tau))
        {
          vectrunc_append(L->Sml2, pr);
          vecsmalltrunc_append(L->ESml2, vp);
        }
      }
    }
  }
  factell = idealprimedec(nfz,utoipos(ell)); l = lg(factell);
  for (i=1; i<l; i++)
  {
    pr = gel(factell,i);
    if (!idealval(nfz,gothf,pr) && !isconjinprimelist(L->Sl,pr,tau))
      vectrunc_append(L->Sl, pr);
  }
  return 0; /* OK */
}

/* Return a Flm */
static GEN
logall(GEN nf, GEN vec, long lW, long mginv, long ell, GEN pr, long ex)
{
  GEN m, M, sprk = log_prk_init(nf, pr, ex);
  long ellrank, i, l = lg(vec);

  ellrank = prank(gel(sprk,1), ell);
  M = cgetg(l,t_MAT);
  for (i=1; i<l; i++)
  {
    m = log_prk(nf, gel(vec,i), sprk);
    setlg(m, ellrank+1);
    if (i < lW) m = gmulsg(mginv, m);
    gel(M,i) = ZV_to_Flv(m, ell);
  }
  return M;
}

/* compute the u_j (see remark 5.2.15.) */
static GEN
get_u(GEN cyc, long rc, ulong ell)
{
  long i, l = lg(cyc);
  GEN u = cgetg(l,t_VECSMALL);
  for (i=1; i<=rc; i++) uel(u,i) = 0;
  for (   ; i < l; i++) uel(u,i) = Fl_inv(umodiu(gel(cyc,i), ell), ell);
  return u;
}

/* alg. 5.2.15. with remark */
static GEN
isprincipalell(GEN bnfz, GEN id, GEN cycgen, GEN u, ulong ell, long rc)
{
  long i, l = lg(cycgen);
  GEN v, b, db, y = bnfisprincipal0(bnfz, id, nf_FORCE|nf_GENMAT);

  v = ZV_to_Flv(gel(y,1), ell);
  b = gel(y,2);
  if (typ(b) == t_COL)
  {
    b = Q_remove_denom(gel(y,2), &db);
    if (db) b = famat_mulpows_shallow(b, db, -1);
  }
  for (i=rc+1; i<l; i++)
  {
    ulong e = Fl_mul( uel(v,i), uel(u,i), ell);
    b = famat_mulpows_shallow(b, gel(cycgen,i), e);
  }
  setlg(v,rc+1); return mkvec2(v, b);
}

static GEN
famat_factorback(GEN v, GEN e)
{
  long i, l = lg(e);
  GEN V = trivial_fact();
  for (i=1; i<l; i++) V = famat_mulpow_shallow(V, gel(v,i), gel(e,i));
  return V;
}

static GEN
famat_factorbacks(GEN v, GEN e)
{
  long i, l = lg(e);
  GEN V = trivial_fact();
  for (i=1; i<l; i++) V = famat_mulpows_shallow(V, gel(v,i), uel(e,i));
  return V;
}

static GEN
compute_beta(GEN X, GEN vecWB, GEN ell, GEN bnfz)
{
  GEN BE, be;
  BE = famat_reduce(famat_factorbacks(vecWB, X));
  gel(BE,2) = centermod(gel(BE,2), ell);
  be = nffactorback(bnfz, BE, NULL);
  be = reducebeta(bnfz, be, ell);
  if (DEBUGLEVEL>1) err_printf("beta reduced = %Ps\n",be);
  return be;
}

static GEN
get_Selmer(GEN bnf, GEN cycgen, long rc)
{
  GEN U = bnf_build_units(bnf), tu = gel(U,1), fu = vecslice(U, 2, lg(U)-1);
  return shallowconcat(vec_append(fu,tu), vecslice(cycgen,1,rc));
}

GEN
lift_if_rational(GEN x)
{
  long lx, i;
  GEN y;

  switch(typ(x))
  {
    default: break;

    case t_POLMOD:
      y = gel(x,2);
      if (typ(y) == t_POL)
      {
        long d = degpol(y);
        if (d > 0) return x;
        return (d < 0)? gen_0: gel(y,2);
      }
      return y;

    case t_POL: lx = lg(x);
      for (i=2; i<lx; i++) gel(x,i) = lift_if_rational(gel(x,i));
      break;
    case t_VEC: case t_COL: case t_MAT: lx = lg(x);
      for (i=1; i<lx; i++) gel(x,i) = lift_if_rational(gel(x,i));
  }
  return x;
}

/* A column vector representing a subgroup of prime index */
static GEN
grptocol(GEN H)
{
  long i, j, l = lg(H);
  GEN col = cgetg(l, t_VECSMALL);
  for (i = 1; i < l; i++)
  {
    ulong ell = itou( gcoeff(H,i,i) );
    if (ell == 1) col[i] = 0; else { col[i] = ell-1; break; }
  }
  for (j=i; ++j < l; ) col[j] = itou( gcoeff(H,i,j) );
  return col;
}

/* Reorganize kernel basis so that the tests of ok_congruence can be ok
 * for y[ncyc]=1 and y[1..ncyc]=1 */
static GEN
fix_kernel(GEN K, GEN M, GEN vecMsup, long lW, long ell)
{
  pari_sp av = avma;
  long i, j, idx, ffree, dK = lg(K)-1;
  GEN Ki, Kidx = cgetg(dK+1, t_VECSMALL);

  /* First step: Gauss elimination on vectors lW...lg(M)-1 */
  for (idx = lg(K), i = lg(M)-1; i >= lW; i--)
  {
    for (j = dK; j > 0; j--) if (coeff(K, i, j)) break;
    if (!j || j == dK) continue;
    /* ensure that K[i,dK] != 0 */
    for (j = idx; j < dK; j++)
      if (coeff(K, i, j) && coeff(K, Kidx[j], dK) != ell - 1)
        Flv_add_inplace(gel(K,dK), gel(K,j), ell);
    idx--;
    if (j != idx) swap(gel(K, j), gel(K, idx));
    Kidx[idx] = i;
    if (coeff(K,i,idx) != 1)
      Flv_Fl_div_inplace(gel(K,idx), coeff(K,i,idx), ell);
    Ki = gel(K,idx);
    if (coeff(K,i,dK) != 1)
    {
      ulong t = Fl_sub(coeff(K,i,dK), 1, ell);
      Flv_sub_inplace(gel(K,dK), Flv_Fl_mul(Ki, t, ell), ell);
    }
    for (j = dK; --j > 0; )
    {
      if (j == idx) continue;
      if (coeff(K,i,j))
        Flv_sub_inplace(gel(K,j), Flv_Fl_mul(Ki, coeff(K,i,j), ell), ell);
    }
  }
  /* ffree = first vector that is not "free" for the scalar products */
  ffree = idx;
  /* Second step: for each hyperplane equation in vecMsup, do the same
   * thing as before. */
  for (i=1; i < lg(vecMsup); i++)
  {
    GEN Msup = gel(vecMsup,i);
    ulong dotprod;
    if (lgcols(Msup) != 2) continue;
    Msup = zm_row(Msup, 1);
    for (j=ffree; j > 0; j--)
    {
      dotprod = Flv_dotproduct(Msup, gel(K,j), ell);
      if (dotprod)
      {
        if (j != --ffree) swap(gel(K, j), gel(K, ffree));
        if (dotprod != 1) Flv_Fl_div_inplace(gel(K, ffree), dotprod, ell);
        break;
      }
    }
    if (!j)
    { /* Do our best to ensure that vecMsup.K[dK] != 0 */
      if (Flv_dotproduct(Msup, gel(K,dK), ell) == 0)
      {
        for (j = ffree-1; j <= dK; j++)
          if (Flv_dotproduct(Msup, gel(K,j), ell)
              && coeff(K,Kidx[j],dK) != ell-1)
            Flv_add_inplace(gel(K,dK), gel(K,j), ell);
      }
      continue;
    }
    Ki = gel(K,ffree);
    dotprod = Flv_dotproduct(Msup, gel(K,dK), ell);
    if (dotprod != 1)
    {
      ulong t = Fl_sub(dotprod,1,ell);
      Flv_sub_inplace(gel(K,dK), Flv_Fl_mul(Ki,t,ell), ell);
    }
    for (j = dK; j > 0; j--)
    {
      if (j == ffree) continue;
      dotprod = Flv_dotproduct(Msup, gel(K,j), ell);
      if (dotprod) Flv_sub_inplace(gel(K,j), Flv_Fl_mul(Ki,dotprod,ell), ell);
    }
  }
  if (ell == 2)
  {
    for (i = ffree, j = ffree-1; i <= dK && j; i++, j--)
    { swap(gel(K,i), gel(K,j)); }
  }
  /* Try to ensure that y = vec_ei(n, i) gives a good candidate */
  for (i = 1; i < dK; i++) Flv_add_inplace(gel(K,i), gel(K,dK), ell);
  return gerepilecopy(av, K);
}

static GEN
Flm_init(long m, long n)
{
  GEN M = cgetg(n+1, t_MAT);
  long i; for (i = 1; i <= n; i++) gel(M,i) = cgetg(m+1, t_VECSMALL);
  return M;
}
static void
Flv_fill(GEN v, GEN y)
{
  long i, l = lg(y);
  for (i = 1; i < l; i++) v[i] = y[i];
}

static GEN
get_badbnf(GEN bnf)
{
  long i, l;
  GEN bad = gen_1, gen = bnf_get_gen(bnf);
  l = lg(gen);
  for (i = 1; i < l; i++)
  {
    GEN g = gel(gen,i);
    bad = lcmii(bad, gcoeff(g,1,1));
  }
  return bad;
}
/* Let K base field, L/K described by bnr (conductor f) + H. Return a list of
 * primes coprime to f*ell of degree 1 in K whose images in Cl_f(K) generate H:
 * thus they all split in Lz/Kz; t in Kz is such that
 * t^(1/p) generates Lz => t is an ell-th power in k(pr) for all such primes.
 * Restrict to primes not dividing
 * - the index fz of the polynomial defining Kz, or
 * - the modulus, or
 * - ell, or
 * - a generator in bnf.gen or bnfz.gen */
static GEN
get_prlist(GEN bnr, GEN H, ulong ell, GEN bnfz)
{
  pari_sp av0 = avma;
  forprime_t T;
  ulong p;
  GEN L, nf, cyc, bad, cond, condZ, Hsofar;
  L = cgetg(1, t_VEC);
  cyc = bnr_get_cyc(bnr);
  nf = bnr_get_nf(bnr);

  cond = gel(bnr_get_mod(bnr), 1);
  condZ = gcoeff(cond,1,1);
  bad = get_badbnf(bnr_get_bnf(bnr));
  if (bnfz)
  {
    GEN badz = lcmii(get_badbnf(bnfz), nf_get_index(bnf_get_nf(bnfz)));
    bad = mulii(bad,badz);
  }
  bad = lcmii(muliu(condZ, ell), bad);
  /* restrict to primes not dividing bad */

  u_forprime_init(&T, 2, ULONG_MAX);
  Hsofar = cgetg(1, t_MAT);
  while ((p = u_forprime_next(&T)))
  {
    GEN LP;
    long i, l;
    if (p == ell || !umodiu(bad, p)) continue;
    LP = idealprimedec_limit_f(nf, utoipos(p), 1);
    l = lg(LP);
    for (i = 1; i < l; i++)
    {
      pari_sp av = avma;
      GEN M, P = gel(LP,i), v = bnrisprincipal(bnr, P, 0);
      if (!hnf_invimage(H, v)) { set_avma(av); continue; }
      M = shallowconcat(Hsofar, v);
      M = ZM_hnfmodid(M, cyc);
      if (ZM_equal(M, Hsofar)) continue;
      L = vec_append(L, P);
      Hsofar = M;
      /* the primes in L generate H */
      if (ZM_equal(M, H)) return gerepilecopy(av0, L);
    }
  }
  pari_err_BUG("rnfkummer [get_prlist]");
  return NULL;
}
/*Lprz list of prime ideals in Kz that must split completely in Lz/Kz, vecWA
 * generators for the S-units used to build the Kummer generators. Return
 * matsmall M such that \prod WA[j]^x[j] ell-th power mod pr[i] iff
 * \sum M[i,j] x[j] = 0 (mod ell) */
static GEN
subgroup_info(GEN bnfz, GEN Lprz, long ell, GEN vecWA)
{
  GEN nfz = bnf_get_nf(bnfz), M, gell = utoipos(ell), Lell = mkvec(gell);
  long i, j, l = lg(vecWA), lz = lg(Lprz);
  M = cgetg(l, t_MAT);
  for (j=1; j<l; j++) gel(M,j) = cgetg(lz, t_VECSMALL);
  for (i=1; i < lz; i++)
  {
    GEN pr = gel(Lprz,i), EX = subiu(pr_norm(pr), 1);
    GEN N, g,T,p, prM = idealhnf(nfz, pr);
    GEN modpr = zk_to_Fq_init(nfz, &pr,&T,&p);
    long v = Z_lvalrem(divis(EX,ell), ell, &N) + 1; /* Norm(pr)-1 = N * ell^v */
    GEN ellv = powuu(ell, v);
    g = gener_Fq_local(T,p, Lell);
    g = Fq_pow(g,N, T,p); /* order ell^v */
    for (j=1; j < l; j++)
    {
      GEN logc, c = gel(vecWA,j);
      if (typ(c) == t_MAT) /* famat */
        c = famat_makecoprime(nfz, gel(c,1), gel(c,2), pr, prM, EX);
      c = nf_to_Fq(nfz, c, modpr);
      c = Fq_pow(c, N, T,p);
      logc = Fq_log(c, g, ellv, T,p);
      ucoeff(M, i,j) = umodiu(logc, ell);
    }
  }
  return M;
}

/* if all>0, give all equations of degree 'all'. Assume bnr modulus is the
 * conductor */
static GEN
rnfkummersimple(GEN bnr, GEN subgroup, long ell, long all)
{
  long i, j, degK, dK, lSml2, lSl2, lSp, rc, lW, prec, rk = 0, ncyc = 0;
  long firstpass = all<0;
  GEN bnf, nf,bid, ideal, arch, cycgen, cyc, Sp, prSp, matP;
  GEN gell, xell, u, M, K, y, vecMsup, vecW, vecWB, vecBp, msign;
  GEN mat = NULL, matgrp = NULL, be1 = NULL, res = NULL;
  primlist L;

  bnf = bnr_get_bnf(bnr); (void)bnf_build_units(bnf);
  nf  = bnf_get_nf(bnf);
  degK = nf_get_degree(nf);

  bid = bnr_get_bid(bnr);
  ideal= bid_get_ideal(bid);
  arch = bid_get_arch(bid); /* this is the conductor */
  i = build_list_Hecke(&L, nf, bid_get_fact2(bid), ideal, ell, NULL);
  if (i) return no_sol(all,i);

  lSml2 = lg(L.Sml2);
  Sp = shallowconcat(L.Sm, L.Sml1); lSp = lg(Sp);
  prSp = shallowconcat(L.Sml2, L.Sl); lSl2 = lg(prSp);

  cycgen = bnf_build_cycgen(bnf);
  cyc = bnf_get_cyc(bnf); rc = prank(cyc, ell);

  vecW = get_Selmer(bnf, cycgen, rc);
  u = get_u(cyc, rc, ell);

  vecBp = cgetg(lSp, t_VEC);
  matP  = cgetg(lSp, t_MAT);
  for (j = 1; j < lSp; j++)
  {
    GEN L = isprincipalell(bnf,gel(Sp,j), cycgen,u,ell,rc);
    gel( matP,j) = gel(L,1);
    gel(vecBp,j) = gel(L,2);
  }
  vecWB = shallowconcat(vecW, vecBp);

  prec = DEFAULTPREC +
      nbits2extraprec(((degK-1) * (gexpo(vecWB) + gexpo(nf_get_M(nf)))));
  if (nf_get_prec(nf) < prec) nf = nfnewprec_shallow(nf, prec);
  msign = nfsign(nf, vecWB);
  arch = ZV_to_zv(arch);

  vecMsup = cgetg(lSml2,t_VEC);
  M = NULL;
  for (i = 1; i < lSl2; i++)
  {
    GEN pr = gel(prSp,i);
    long e = pr_get_e(pr), z = ell * (e / (ell-1));

    if (i < lSml2)
    {
      z += 1 - L.ESml2[i];
      gel(vecMsup,i) = logall(nf, vecWB, 0,0, ell, pr,z+1);
    }
    M = vconcat(M, logall(nf, vecWB, 0,0, ell, pr,z));
  }
  lW = lg(vecW);
  M = vconcat(M, shallowconcat(zero_Flm(rc,lW-1), matP));
  if (!all)
  { /* primes landing in subgroup must be totally split */
    GEN Lpr = get_prlist(bnr, subgroup, ell, NULL);
    GEN M2 = subgroup_info(bnf, Lpr, ell, vecWB);
    M = vconcat(M, M2);
  }
  K = Flm_ker(M, ell);
  if (all < 0) K = fix_kernel(K, M, vecMsup, lW, ell);
  dK = lg(K)-1;
  y = cgetg(dK+1,t_VECSMALL);
  if (all) res = cgetg(1,t_VEC); /* in case all = 1 */
  if (all < 0)
  {
    ncyc = dK; rk = 0; mat = Flm_init(dK, ncyc);
    if (all == -1) matgrp = Flm_init(lg(bnr_get_cyc(bnr)), ncyc+1);
  }
  xell = pol_xn(ell, 0);
  gell = utoipos(ell);
  do {
    dK = lg(K)-1;
    while (dK)
    {
      for (i=1; i<dK; i++) y[i] = 0;
      y[i] = 1; /* y = [0,...,0,1,0,...,0], 1 at i'th position */
      do
      {
        pari_sp av = avma;
        GEN be, P=NULL, X;
        if (all < 0)
        {
          Flv_fill(gel(mat, rk+1), y);
          setlg(mat, rk+2);
          if (Flm_rank(mat, ell) <= rk) continue;
        }
FOUND:  X = Flm_Flc_mul(K, y, ell);
        if (ok_congruence(X, ell, lW, vecMsup) && ok_sign(X, msign, arch))
        {/* be satisfies all congruences, x^ell - be is irreducible, signature
          * and relative discriminant are correct */
          if (all < 0) rk++;
          be = compute_beta(X, vecWB, gell, bnf);
          be = nf_to_scalar_or_alg(nf, be);
          if (typ(be) == t_POL) be = mkpolmod(be, nf_get_pol(nf));
          if (all == -1)
          {
            pari_sp av2 = avma;
            GEN Kgrp, colgrp = grptocol(rnfnormgroup(bnr, gsub(xell, be)));
            if (ell != 2)
            {
              if (rk == 1) be1 = be;
              else
              { /* Compute the pesky scalar */
                GEN K2, C = cgetg(4, t_MAT);
                gel(C,1) = gel(matgrp,1);
                gel(C,2) = colgrp;
                gel(C,3) = grptocol(rnfnormgroup(bnr, gsub(xell, gmul(be1,be))));
                K2 = Flm_ker(C, ell);
                if (lg(K2) != 2) pari_err_BUG("linear algebra");
                K2 = gel(K2,1);
                if (K2[1] != K2[2])
                  Flv_Fl_mul_inplace(colgrp, Fl_div(K2[2],K2[1],ell), ell);
              }
            }
            Flv_fill(gel(matgrp,rk), colgrp);
            setlg(matgrp, rk+1);
            Kgrp = Flm_ker(matgrp, ell);
            if (lg(Kgrp) == 2)
            {
              setlg(gel(Kgrp,1), rk+1);
              y = Flm_Flc_mul(mat, gel(Kgrp,1), ell);
              all = 0; goto FOUND;
            }
            set_avma(av2);
          }
          else
          {
            P = gsub(xell, be);
            if (all)
              res = shallowconcat(res, gerepileupto(av, P));
            else
            {
              if (ZM_equal(rnfnormgroup(bnr,P),subgroup)) return P; /*DONE*/
              set_avma(av); continue;
            }
          }
          if (all < 0 && rk == ncyc) return res;
          if (firstpass) break;
        }
        else set_avma(av);
      } while (increment(y, dK, ell));
      y[dK--] = 0;
    }
  } while (firstpass--);
  return all? res: gen_0;
}

/* alg. 5.3.11 (return only discrete log mod ell) */
static GEN
isvirtualunit(GEN bnf, GEN v, GEN cycgen, GEN cyc, GEN gell, long rc)
{
  GEN L, b, eps, y, q, nf = bnf_get_nf(bnf), w = idealsqrtn(nf, v, gell, 1);
  long i, l = lg(cycgen);

  L = bnfisprincipal0(bnf, w, nf_GENMAT|nf_FORCE);
  q = gel(L,1);
  if (ZV_equal0(q)) { eps = v; y = q; }
  else
  {
    y = cgetg(l,t_COL);
    for (i=1; i<l; i++) gel(y,i) = diviiexact(mulii(gell,gel(q,i)), gel(cyc,i));
    eps = famat_mulpow_shallow(famat_factorback(cycgen,y), gel(L,2), gell);
    eps = famat_mul_shallow(famat_inv(eps), v);
  }
  setlg(y, rc+1);
  b = bnfisunit(bnf,eps);
  if (lg(b) == 1) pari_err_BUG("isvirtualunit");
  return shallowconcat(lift_shallow(b), y);
}

/* J a vector of elements in nfz = relative extension of nf by polrel,
 * return the Steinitz element attached to the module generated by J */
static GEN
Stelt(GEN nf, GEN J, GEN polrel)
{
  long i, l = lg(J), vx = varn(polrel);
  GEN A = cgetg(l, t_VEC), I = cgetg(l, t_VEC);
  for (i = 1; i < l; i++)
  {
    GEN v = gel(J,i);
    if (typ(v) == t_POL) { v = RgX_rem(v, polrel); setvarn(v,vx); }
    gel(A,i) = v;
    gel(I,i) = gen_1;
  }
  A = RgV_to_RgM(A, degpol(polrel));
  return idealprod(nf, gel(nfhnf(nf, mkvec2(A,I)),2));
}

static GEN
polrelKzK(toK_s *T, GEN x)
{
  GEN P = roots_to_pol(powtau(x, T->m, T->tau), 0);
  long i, l = lg(P);
  for (i=2; i<l; i++) gel(P,i) = downtoK(T, gel(P,i));
  return P;
}

/* N: Cl_m(Kz) --> Cl_m(K), lift subgroup from bnr to bnrz using Algo 4.1.11 */
static GEN
invimsubgroup(GEN bnrz, GEN bnr, GEN subgroup, toK_s *T)
{
  long l, j;
  GEN P, cyc, gen, U, polrel, StZk;
  GEN nf = bnr_get_nf(bnr), nfz = bnr_get_nf(bnrz);
  GEN polz = nf_get_pol(nfz), zkzD = nf_get_zkprimpart(nfz);

  polrel = polrelKzK(T, pol_x(varn(polz)));
  StZk = Stelt(nf, zkzD, polrel);
  cyc = bnr_get_cyc(bnrz); l = lg(cyc);
  gen = bnr_get_gen(bnrz);
  P = cgetg(l,t_MAT);
  for (j=1; j<l; j++)
  {
    GEN g, id = idealhnf_shallow(nfz, gel(gen,j));
    g = Stelt(nf, RgV_RgM_mul(zkzD, id), polrel);
    g = idealdiv(nf, g, StZk); /* N_{Kz/K}(gen[j]) */
    gel(P,j) = isprincipalray(bnr, g);
  }
  (void)ZM_hnfall_i(shallowconcat(P, subgroup), &U, 1);
  setlg(U, l); for (j=1; j<l; j++) setlg(U[j], l);
  return ZM_hnfmodid(U, cyc);
}

static GEN
pol_from_Newton(GEN S)
{
  long i, k, l = lg(S);
  GEN C = cgetg(l+1, t_VEC), c = C + 1;
  gel(c,0) = gen_1;
  gel(c,1) = gel(S,1); /* gen_0 in our case */
  for (k = 2; k < l; k++)
  {
    GEN s = gel(S,k);
    for (i = 2; i < k-1; i++) s = gadd(s, gmul(gel(S,i), gel(c,k-i)));
    gel(c,k) = gdivgs(s, -k);
  }
  return gtopoly(C, 0);
}

/* - mu_b = sum_{0 <= i < m} floor(r_b r_{d-1-i} / ell) tau^i */
static GEN
get_mmu(long b, GEN r, long ell)
{
  long i, m = lg(r)-1;
  GEN M = cgetg(m+1, t_VEC);
  for (i = 0; i < m; i++) gel(M,i+1) = stoi((r[b + 1] * r[m - i]) / ell);
  return M;
}

/* coeffs(x, a..b) in variable v >= varn(x) */
static GEN
split_pol(GEN x, long v, long a, long b)
{
  long i, l = degpol(x);
  GEN y = x + a, z;

  if (l < b) b = l;
  if (a > b || varn(x) != v) return pol_0(v);
  l = b-a + 3;
  z = cgetg(l, t_POL); z[1] = x[1];
  for (i = 2; i < l; i++) gel(z,i) = gel(y,i);
  return normalizepol_lg(z, l);
}

/* return (den_a * z) mod (v^ell - num_a/den_a), assuming deg(z) < 2*ell
 * allow either num/den to be NULL (= 1) */
static GEN
mod_Xell_a(GEN z, long v, long ell, GEN num_a, GEN den_a)
{
  GEN z1 = split_pol(z, v, ell, degpol(z));
  GEN z0 = split_pol(z, v, 0,   ell-1); /* z = v^ell z1 + z0*/
  if (den_a) z0 = gmul(den_a, z0);
  if (num_a) z1 = gmul(num_a, z1);
  return gadd(z0, z1);
}
static GEN
to_alg(GEN nfz, GEN c, long v)
{
  GEN z, D;
  if (typ(c) != t_COL) return c;
  z = gmul(nf_get_zkprimpart(nfz), c);
  if (typ(z) == t_POL) setvarn(z, v);
  D = nf_get_zkden(nfz);
  if (!equali1(D)) z = RgX_Rg_div(z, D);
  return z;
}

/* th. 5.3.5. and prop. 5.3.9. */
static GEN
compute_polrel(struct rnfkummer *kum, GEN be)
{
  toK_s *T = &kum->T;
  long i, k, ell = kum->ell, m = T->m, vT = fetch_var(), vz = fetch_var();
  GEN r, powtaubet, S, p1, root, num_t, den_t, nfzpol, powtau_prim_invbe;
  GEN prim_Rk, C_Rk, prim_root, C_root, prim_invbe, C_invbe;
  GEN nfz = bnf_get_nf(kum->bnfz);
  pari_timer ti;

  r = cgetg(m+1,t_VECSMALL); /* r[i+1] = g^i mod ell */
  r[1] = 1;
  for (i=2; i<=m; i++) r[i] = (r[i-1] * kum->g) % ell;
  powtaubet = powtau(be, m, T->tau);
  if (DEBUGLEVEL>1) { err_printf("Computing Newton sums: "); timer_start(&ti); }
  prim_invbe = Q_primitive_part(nfinv(nfz, be), &C_invbe);
  powtau_prim_invbe = powtau(prim_invbe, m, T->tau);

  root = cgetg(ell + 2, t_POL);
  root[1] = evalsigne(1) | evalvarn(0);
  for (i = 0; i < ell; i++) gel(root,2+i) = gen_0;
  for (i = 0; i < m; i++)
  { /* compute (1/be) ^ (-mu) instead of be^mu [mu << 0].
     * 1/be = C_invbe * prim_invbe */
    GEN mmu = get_mmu(i, r, ell);
    /* p1 = prim_invbe ^ -mu */
    p1 = to_alg(nfz, nffactorback(nfz, powtau_prim_invbe, mmu), vz);
    if (C_invbe) p1 = gmul(p1, powgi(C_invbe, RgV_sumpart(mmu, m)));
    /* root += zeta_ell^{r_i} T^{r_i} be^mu_i */
    gel(root, 2 + r[i+1]) = monomial(p1, r[i+1], vT);
  }
  /* Other roots are as above with z_ell --> z_ell^j.
   * Treat all contents (C_*) and principal parts (prim_*) separately */
  prim_Rk = prim_root = Q_primitive_part(root, &C_root);
  C_Rk = C_root;

  r = vecsmall_reverse(r); /* theta^ell = be^( sum tau^a r_{d-1-a} ) */
  /* Compute modulo X^ell - 1, T^ell - t, nfzpol(vz) */
  p1 = to_alg(nfz, nffactorback(nfz, powtaubet, r), vz);
  num_t = Q_remove_denom(p1, &den_t);

  nfzpol = leafcopy(nf_get_pol(nfz));
  setvarn(nfzpol, vz);
  S = cgetg(ell+1, t_VEC); /* Newton sums */
  gel(S,1) = gen_0;
  for (k = 2; k <= ell; k++)
  { /* compute the k-th Newton sum */
    pari_sp av = avma;
    GEN z, D, Rk = gmul(prim_Rk, prim_root);
    C_Rk = mul_content(C_Rk, C_root);
    Rk = mod_Xell_a(Rk, 0, ell, NULL, NULL); /* mod X^ell - 1 */
    for (i = 2; i < lg(Rk); i++)
    {
      if (typ(gel(Rk,i)) != t_POL) continue;
      z = mod_Xell_a(gel(Rk,i), vT, ell, num_t,den_t); /* mod T^ell - t */
      gel(Rk,i) = RgXQX_red(z, nfzpol); /* mod nfz.pol */
    }
    if (den_t) C_Rk = mul_content(C_Rk, ginv(den_t));
    prim_Rk = Q_primitive_part(Rk, &D);
    C_Rk = mul_content(C_Rk, D); /* root^k = prim_Rk * C_Rk */

    /* Newton sum is ell * constant coeff (in X), which has degree 0 in T */
    z = polcoef_i(prim_Rk, 0, 0);
    z = polcoef_i(z      , 0,vT);
    z = downtoK(T, gmulgs(z, ell));
    if (C_Rk) z = gmul(z, C_Rk);
    gerepileall(av, C_Rk? 3: 2, &z, &prim_Rk, &C_Rk);
    if (DEBUGLEVEL>1) err_printf("%ld(%ld) ", k, timer_delay(&ti));
    gel(S,k) = z;
  }
  if (DEBUGLEVEL>1) err_printf("\n");
  (void)delete_var();
  (void)delete_var(); return pol_from_Newton(S);
}

/* lift elt t in nf to nfz, algebraic form */
static GEN
lifttoKz(GEN nf, GEN t, compo_s *C)
{
  GEN x = nf_to_scalar_or_alg(nf, t);
  if (typ(x) != t_POL) return x;
  return RgX_RgXQ_eval(x, C->p, C->R);
}
/* lift ideal id in nf to nfz */
static GEN
ideallifttoKz(GEN nfz, GEN nf, GEN id, compo_s *C)
{
  GEN I = idealtwoelt(nf,id);
  GEN x = nf_to_scalar_or_alg(nf, gel(I,2));
  if (typ(x) != t_POL) return gel(I,1);
  gel(I,2) = algtobasis(nfz, RgX_RgXQ_eval(x, C->p, C->R));
  return idealhnf_two(nfz,I);
}
/* lift ideal pr in nf to ONE prime in nfz (the others are conjugate under tau
 * and bring no further information on e_1 W). Assume pr coprime to
 * index of both nf and nfz, and unramified in Kz/K (minor simplification) */
static GEN
prlifttoKz(GEN nfz, GEN nf, GEN pr, compo_s *C)
{
  GEN F, p = pr_get_p(pr), t = pr_get_gen(pr), T = nf_get_pol(nfz);
  if (nf_get_degree(nf) != 1)
  { /* restrict to primes above pr */
    t = Q_primpart( lifttoKz(nf,t,C) );
    T = FpX_gcd(FpX_red(T,p), FpX_red(t,p), p);
    T = FpX_normalize(T, p);
  }
  F = FpX_factor(T, p);
  return idealprimedec_kummer(nfz,gcoeff(F,1,1), pr_get_e(pr), p);
}
static GEN
get_przlist(GEN L, GEN nfz, GEN nf, compo_s *C)
{
  long i, l;
  GEN M = cgetg_copy(L, &l);
  for (i = 1; i < l; i++) gel(M,i) = prlifttoKz(nfz, nf, gel(L,i), C);
  return M;
}

static void
compositum_red(compo_s *C, GEN P, GEN Q)
{
  GEN p, q, a, z = gel(compositum2(P, Q),1);
  a = gel(z,1);
  p = gel(gel(z,2), 2);
  q = gel(gel(z,3), 2);
  C->k = itos( gel(z,4) );
  /* reduce R. FIXME: should be polredbest(a, 1), but breaks rnfkummer bench */
  z = polredabs0(a, nf_ORIG|nf_PARTIALFACT);
  C->R = gel(z,1);
  a = gel(gel(z,2), 2);
  C->p = RgX_RgXQ_eval(p, a, C->R);
  C->q = RgX_RgXQ_eval(q, a, C->R);
  C->rev = QXQ_reverse(a, C->R);
}

/* replace P->C^(-deg P) P(xC) for the largest integer C such that coefficients
 * remain algebraic integers. Lift *rational* coefficients */
static void
nfX_Z_normalize(GEN nf, GEN P)
{
  long i, l;
  GEN C, Cj, PZ = cgetg_copy(P, &l);
  PZ[1] = P[1];
  for (i = 2; i < l; i++) /* minor variation on RgX_to_nfX (create PZ) */
  {
    GEN z = nf_to_scalar_or_basis(nf, gel(P,i));
    if (typ(z) == t_INT)
      gel(PZ,i) = gel(P,i) = z;
    else
      gel(PZ,i) = ZV_content(z);
  }
  (void)ZX_Z_normalize(PZ, &C);

  if (C == gen_1) return;
  Cj = C;
  for (i = l-2; i > 1; i--)
  {
    if (i != l-2) Cj = mulii(Cj, C);
    gel(P,i) = gdiv(gel(P,i), Cj);
  }
}

/* set kum->vecC, kum->Q */
static void
_rnfkummer_step4(struct rnfkummer *kum, GEN cycgen, long d, long m)
{
  long i, j, rc = kum->rc;
  GEN Q, vecC, vecB = cgetg(rc+1,t_VEC), Tc = cgetg(rc+1,t_MAT);
  GEN gen = bnf_get_gen(kum->bnfz), u = kum->u;
  ulong ell = kum->ell;
  for (j=1; j<=rc; j++)
  {
    GEN p1 = tauofideal(gel(gen,j), &kum->tau);
    p1 = isprincipalell(kum->bnfz, p1, cycgen,u,ell,rc);
    gel(Tc,j)  = gel(p1,1);
    gel(vecB,j)= gel(p1,2);
  }

  if (!rc) vecC = cgetg(1,t_VEC);
  else
  {
    GEN p1 = Flm_powers(Tc, m-2, ell), p2 = vecB;
    vecC = const_vec(rc, trivial_fact());
    for (j=1; j<=m-1; j++)
    {
      GEN z = Flm_Fl_mul(gel(p1,m-j), Fl_mul(j,d,ell), ell);
      p2 = tauofvec(p2, &kum->tau);
      for (i=1; i<=rc; i++)
        gel(vecC,i) = famat_mul_shallow(gel(vecC,i),
                                        famat_factorbacks(p2, gel(z,i)));
    }
    for (i=1; i<=rc; i++) gel(vecC,i) = famat_reduce(gel(vecC,i));
  }
  Q = Flm_ker(Flm_Fl_add(Flm_transpose(Tc), Fl_neg(kum->g, ell), ell), ell);
  kum->vecC = vecC;
  kum->Q = Q;
}

/* set kum->vecW */
static void
_rnfkummer_step5(struct rnfkummer *kum, GEN vselmer, GEN cycgen)
{
  GEN bnfz = kum->bnfz, cyc = bnf_get_cyc(bnfz);
  long ru = (nf_get_degree(bnf_get_nf(bnfz))>>1)-1;
  long j, lW, rc = kum->rc, rv = rc+ru+1;
  ulong ell = kum->ell;
  GEN P, vecW, gell = utoipos(ell), Tv = cgetg(rv+1,t_MAT);
  for (j = 1; j <= rv; j++)
  {
    GEN p1 = tauofelt(gel(vselmer,j), &kum->tau);
    if (typ(p1) == t_MAT) /* famat */
      p1 = nffactorback(bnfz, gel(p1,1), FpC_red(gel(p1,2),gell));
    gel(Tv,j) = ZV_to_Flv(isvirtualunit(bnfz, p1, cycgen,cyc,gell,rc), ell);
  }
  P = Flm_ker(Flm_Fl_add(Tv, Fl_neg(kum->g, ell), ell), ell);
  lW = lg(P);
  kum->vecW = vecW = cgetg(lW,t_VEC);
  for (j=1; j<lW; j++) gel(vecW,j) = famat_factorbacks(vselmer, gel(P,j));
}

static GEN
_rnfkummer_step18(struct rnfkummer *kum, GEN bnr, GEN subgroup, GEN M,
     GEN vecWB, GEN vecMsup, long all)
{
  ulong ell = kum->ell;
  long i, dK, ncyc = 0, firstpass = all < 0, rk = 0, lW = lg(kum->vecW);
  GEN K, y, nf = bnr_get_nf(bnr), gell = utoipos(ell), res = NULL, mat = NULL;

  K = Flm_ker(M, ell);
  if (all < 0) K = fix_kernel(K, M, vecMsup, lW, ell);
  if (DEBUGLEVEL>2) err_printf("Step 18\n");
  dK = lg(K)-1;
  y = cgetg(dK+1,t_VECSMALL);
  if (all) res = cgetg(1, t_VEC);
  if (all < 0) { ncyc = dK; rk = 0; mat = zero_Flm(lg(M)-1, ncyc); }

  do {
    dK = lg(K)-1;
    while (dK)
    {
      for (i=1; i<dK; i++) y[i] = 0;
      y[i] = 1; /* y = [0,...,0,1,0,...,0], 1 at dK'th position */
      do
      { /* cf. algo 5.3.18 */
        GEN H, be, P, X = Flm_Flc_mul(K, y, ell);
        if (ok_congruence(X, ell, lW, vecMsup))
        {
          pari_sp av = avma;
          if (all < 0)
          {
            gel(mat, rk+1) = X;
            if (Flm_rank(mat,ell) <= rk) continue;
            rk++;
          }
          be = compute_beta(X, vecWB, gell, kum->bnfz);
          P = compute_polrel(kum, be);
          nfX_Z_normalize(nf, P);
          if (DEBUGLEVEL>1) err_printf("polrel(beta) = %Ps\n", P);
          if (!all) {
            H = rnfnormgroup(bnr, P);
            if (ZM_equal(subgroup, H)) return P; /* DONE */
            set_avma(av); continue;
          } else {
            GEN P0 = Q_primpart(lift_shallow(P));
            GEN g = nfgcd(P0, RgX_deriv(P0), nf_get_pol(nf), nf_get_index(nf));
            if (degpol(g)) continue;
            H = rnfnormgroup(bnr, P);
            if (!ZM_equal(subgroup,H) && !bnrisconductor(bnr,H)) continue;
          }
          P = gerepilecopy(av, P);
          res = shallowconcat(res, P);
          if (all < 0 && rk == ncyc) return res;
          if (firstpass) break;
        }
      } while (increment(y, dK, ell));
      y[dK--] = 0;
    }
  } while (firstpass--);
  if (!res) pari_err_BUG("kummer [no solution]");
  return res;
}

/* alg 5.3.5 */
static void
rnfkummer_init(struct rnfkummer *kum, GEN bnf, ulong ell, long prec)
{
  compo_s *COMPO = &kum->COMPO;
  toK_s *T = &kum->T;
  GEN nf  = bnf_get_nf(bnf), polnf = nf_get_pol(nf), vselmer, bnfz, cyc, cycgen;
  long degK, degKz, m, d;
  ulong g;
  pari_timer ti;
  if (DEBUGLEVEL>2) err_printf("Step 1\n");
  compositum_red(COMPO, polnf, polcyclo(ell, varn(polnf)));
  if (DEBUGLEVEL)
  {
    timer_printf(&ti, "[rnfkummer] compositum");
    if (DEBUGLEVEL>1) err_printf("polred(compositum) = %Ps\n",COMPO->R);
  }
  if (DEBUGLEVEL>2) err_printf("Step 2\n");
  degK  = degpol(polnf);
  degKz = degpol(COMPO->R);
  m = degKz / degK;
  d = (ell-1) / m;
  g = Fl_powu(pgener_Fl(ell), d, ell);
  if (Fl_powu(g, m, ell*ell) == 1) g += ell;
  /* ord(g) = m in all (Z/ell^k)^* */
  if (DEBUGLEVEL>2) err_printf("Step 3\n");
  /* could factor disc(R) using th. 2.1.6. */
  kum->bnfz = bnfz = Buchall(COMPO->R, nf_FORCE, maxss(prec,BIGDEFAULTPREC));
  if (DEBUGLEVEL) timer_printf(&ti, "[rnfkummer] bnfinit(Kz)");
  cycgen = bnf_build_cycgen(bnfz);
  cyc = bnf_get_cyc(bnfz);
  kum->ell = ell;
  kum->rc = prank(cyc, ell);
  kum->u = get_u(cyc, kum->rc, ell);
  kum->g = g;

  vselmer = get_Selmer(bnfz, cycgen, kum->rc);
  if (DEBUGLEVEL) timer_printf(&ti, "[rnfkummer] Selmer group");
  get_tau(kum);
  if (DEBUGLEVEL>2) err_printf("Step 4\n");
  _rnfkummer_step4(kum, cycgen, d, m);
  if (DEBUGLEVEL>2) err_printf("Step 5\n");
  _rnfkummer_step5(kum, vselmer, cycgen);
  if (DEBUGLEVEL>2) err_printf("Step 8\n");
  /* left inverse */
  T->invexpoteta1 = RgM_inv(RgXQ_matrix_pow(COMPO->p, degKz, degK, COMPO->R));
  T->polnf = polnf;
  T->tau = &kum->tau;
  T->m = m;
  T->powg = Fl_powers(g, m, ell);
}

static GEN
rnfkummer_ell(struct rnfkummer *kum, GEN bnr, GEN subgroup, long all)
{
  ulong ell = kum->ell, mginv;
  GEN bnfz = kum->bnfz, nfz = bnf_get_nf(bnfz), cycgen = bnf_build_cycgen(bnfz);
  GEN nf = bnr_get_nf(bnr), bid = bnr_get_bid(bnr), ideal = bid_get_ideal(bid);
  GEN vecC = kum->vecC, vecW = kum->vecW, u = kum->u, Q = kum->Q;
  long lW = lg(vecW), rc = kum->rc, i, j, lSml2, lSp, lSl2, dc;
  toK_s *T = &kum->T;
  primlist L;
  GEN gothf, idealz, Sp, prSp, vecAp, vecBp, matP, vecWA, vecWB, vecMsup, M;

  idealz = ideallifttoKz(nfz, nf, ideal, &kum->COMPO);
  if (umodiu(gcoeff(ideal,1,1), ell)) gothf = idealz;
  else
  { /* ell | N(ideal) */
    GEN bnrz = Buchray(bnfz, idealz, nf_INIT|nf_GEN);
    GEN subgroupz = invimsubgroup(bnrz, bnr, subgroup, T);
    gothf = bnrconductor_i(bnrz,subgroupz,0);
  }
  if (DEBUGLEVEL>2) err_printf("Step 9, 10 and 11\n");
  i = build_list_Hecke(&L, nfz, NULL, gothf, ell, T->tau);
  if (i) return no_sol(all,i);

  lSml2 = lg(L.Sml2);
  Sp = shallowconcat(L.Sm, L.Sml1); lSp = lg(Sp);
  prSp = shallowconcat(L.Sml2, L.Sl); lSl2 = lg(prSp);

  if (DEBUGLEVEL>2) err_printf("Step 12\n");
  vecAp = cgetg(lSp, t_VEC);
  vecBp = cgetg(lSp, t_VEC);
  matP  = cgetg(lSp, t_MAT);
  for (j = 1; j < lSp; j++)
  {
    GEN e, a;
    GEN p1 = isprincipalell(bnfz, gel(Sp,j), cycgen,u,ell,rc);
    e = gel(p1,1); gel(matP,j) = gel(p1, 1);
    a = gel(p1,2);
    gel(vecBp,j) = famat_mul_shallow(famat_factorbacks(vecC, zv_neg(e)), a);
    gel(vecAp,j) = lambdaofelt(gel(vecBp,j), T);
  }
  if (DEBUGLEVEL>2) err_printf("Step 13\n");
  vecWA = shallowconcat(vecW, vecAp);
  vecWB = shallowconcat(vecW, vecBp);

  if (DEBUGLEVEL>2) err_printf("Step 14, 15 and 17\n");
  mginv = Fl_div(T->m, kum->g, ell);
  vecMsup = cgetg(lSml2,t_VEC);
  M = NULL;
  for (i = 1; i < lSl2; i++)
  {
    GEN pr = gel(prSp,i);
    long e = pr_get_e(pr), z = ell * (e / (ell-1));

    if (i < lSml2)
    {
      z += 1 - L.ESml2[i];
      gel(vecMsup,i) = logall(nfz, vecWA,lW,mginv,ell, pr,z+1);
    }
    M = vconcat(M, logall(nfz, vecWA,lW,mginv,ell, pr,z));
  }
  dc = lg(Q)-1;
  if (dc)
  {
    GEN QtP = Flm_mul(Flm_transpose(Q), matP, ell);
    M = vconcat(M, shallowconcat(zero_Flm(dc,lW-1), QtP));
  }
  if (!M) M = zero_Flm(1, lSp-1 + lW-1);

  if (!all)
  { /* primes landing in subgroup must be totally split */
    GEN lambdaWB = shallowconcat(lambdaofvec(vecW, T), vecAp);/*vecWB^lambda*/
    GEN Lpr = get_prlist(bnr, subgroup, ell, bnfz);
    GEN Lprz= get_przlist(Lpr, nfz, nf, &kum->COMPO);
    M = vconcat(M, subgroup_info(bnfz, Lprz, ell, lambdaWB));
  }
  if (DEBUGLEVEL>2) err_printf("Step 16\n");
  return _rnfkummer_step18(kum,bnr,subgroup, M, vecWB, vecMsup, all);
}

static GEN
_rnfkummer(GEN bnr, GEN subgroup, long all, long prec)
{
  ulong ell;
  GEN polnf, bnf, nf, gell, p1;
  struct rnfkummer kum;
  pari_timer t;

  if (DEBUGLEVEL) timer_start(&t);
  checkbnr(bnr);
  bnf = bnr_get_bnf(bnr);
  nf  = bnf_get_nf(bnf);
  polnf = nf_get_pol(nf);
  if (!varn(polnf)) pari_err_PRIORITY("rnfkummer", polnf, "=", 0);
  /* step 7 */
  p1 = bnrconductor_i(bnr, subgroup, 2);
  if (DEBUGLEVEL) timer_printf(&t, "[rnfkummer] conductor");
  bnr      = gel(p1,2);
  subgroup = gel(p1,3);
  gell = get_gell(bnr,subgroup,all);
  ell = itou(gell);
  if (ell == 1) return pol_x(0);
  if (!uisprime(ell)) pari_err_IMPL("kummer for composite relative degree");
  if (all && all != -1 && umodiu(bnr_get_no(bnr), ell))
    return cgetg(1, t_VEC);
  if (bnf_get_tuN(bnf) % ell == 0)
    return rnfkummersimple(bnr, subgroup, ell, all);

  if (all == -1) all = 0;
  rnfkummer_init(&kum, bnr_get_bnf(bnr), ell, prec);
  return rnfkummer_ell(&kum, bnr, subgroup, all);
}

GEN
rnfkummer(GEN bnr, GEN subgroup, long all, long prec)
{
  pari_sp av = avma;
  return gerepilecopy(av, _rnfkummer(bnr, subgroup, all, prec));
}

/*******************************************************************/
/*                        bnrclassfield                            */
/*******************************************************************/

/* TODO: could be exported */
static void
gsetvarn(GEN x, long v)
{
  long i;
  switch(typ(x))
  {
    case t_POL: case t_SER:
      setvarn(x, v); return;
    case t_LIST:
      x = list_data(x); if (!x) return;
      /* fall through t_VEC */
    case t_VEC: case t_COL: case t_MAT:
      for (i = lg(x)-1; i > 0; i--) gsetvarn(gel(x,i), v);
  }
}

/* emb root of pol as polmod modulo pol2, return relative polynomial */
static GEN
relative_pol(GEN pol, GEN emb, GEN pol2)
{
  GEN eqn, polrel;
  if (degree(pol)==1) return pol2;
  emb = liftpol(emb);
  eqn = gsub(emb, pol_x(varn(pol)));
  eqn = Q_remove_denom(eqn, NULL);
  polrel = nfgcd(pol2, eqn, pol, NULL);
  return RgX_Rg_div(polrel, leading_coeff(polrel));
}

/* pol defines K/nf */
static GEN
bnrclassfield_tower(GEN bnr, GEN subgroup, GEN TB, GEN p, long finaldeg, long absolute, long prec)
{
  pari_sp av = avma;
  GEN nf, nf2, rnf, bnf, bnf2, bnr2, q, H, dec, cyc, pk, sgpk, pol2, emb, emb2, famod, fa, Lbad;
  long i, r1, ell, sp, spk, last;
  forprime_t iter;

  bnf = bnr_get_bnf(bnr);
  nf = bnf_get_nf(bnf);
  rnf = rnfinit0(nf, TB, 1);
  nf2 = rnf_build_nfabs(rnf, prec);
  gsetvarn(nf2, varn(nf_get_pol(nf)));
  r1 = nf_get_r1(nf2);
  bnf2 = Buchall(nf2, nf_FORCE, prec);

  sp = itos(p);
  spk = sp * rnf_get_degree(rnf);
  pk = stoi(spk);
  sgpk = hnfmodid(subgroup,pk);
  last = spk==finaldeg;

  /* compute conductor */
  famod = gel(bid_get_fact2(bnr_get_bid(bnr)),1);
  if (lg(famod)==1)
  {
    fa = trivial_fact();
    Lbad = cgetg(1, t_VECSMALL);
  }
  else
  {
    long j=1;
    fa = cgetg(3, t_MAT);
    gel(fa,1) = cgetg(lg(famod), t_VEC);
    Lbad = cgetg(lg(famod), t_VEC);
    for(i=1; i<lg(famod); i++)
    {
      GEN pr = gel(famod,i);
      gmael(fa,1,i) = rnfidealprimedec(rnf, pr);
      q = pr_get_p(pr);
      if (lgefint(q) == 3) gel(Lbad,j++) = q;
    }
    setlg(Lbad,j);
    Lbad = ZV_to_zv(ZV_sort_uniq(Lbad));
    gel(fa,1) = shallowconcat1(gel(fa,1));
    settyp(gel(fa,1), t_COL);
    gel(fa,2) = cgetg(lg(gel(fa,1)), t_COL);
    for (i=1; i<lg(gel(fa,1)); i++)
    {
      GEN pr = gcoeff(fa,i,1);
      long e = equalii(p, pr_get_p(pr))? 1 + (pr_get_e(pr)*sp) / (sp-1): 1;
      gcoeff(fa,i,2) = utoipos(e);
    }
  }
  bnr2 = bnrinit0(bnf2, mkvec2(fa, const_vec(r1,gen_1)), 0);

  /* compute subgroup */
  cyc = bnr_get_cyc(bnr2);
  H = Flm_image(zv_diagonal(ZV_to_Flv(cyc,sp)), sp);
  u_forprime_init(&iter, 2, ULONG_MAX);
  while ((ell = u_forprime_next(&iter))) if (!zv_search(Lbad, ell))
  {
    dec = idealprimedec_limit_f(nf, utoi(ell), 1);
    for (i=1; i<lg(dec); i++)
    {
      GEN pr = gel(dec,i), Pr = gel(rnfidealprimedec(rnf, pr), 1);
      long f = pr_get_f(Pr) / pr_get_f(pr);
      GEN vpr = FpC_Fp_mul(isprincipalray(bnr, pr), utoi(f), pk);
      if (gequal0(ZC_hnfrem(vpr,sgpk)))
        H = vec_append(H, ZV_to_Flv(isprincipalray(bnr2, Pr), sp));
    }
    if (lg(H) > lg(cyc)+3)
    {
      H = Flm_image(H, sp);
      if (lg(cyc)-lg(H) == 1) break;
    }
  }
  H = hnfmodid(shallowconcat(zm_to_ZM(H), diagonal_shallow(cyc)), p);

  /* polynomial over nf2 */
  pol2 = _rnfkummer(bnr2, H, 0, prec);
  /* absolute polynomial */
  pol2 = rnfequation2(nf2, pol2);
  emb2 = gel(pol2,2); /* generator of nf2 as polmod modulo pol2 */
  pol2 = gel(pol2,1);
  /* polynomial over nf */
  if (!absolute || !last)
  {
    emb = rnf_get_alpha(rnf); /* generator of nf as polynomial in nf2 */
    emb = poleval(emb, emb2); /* generator of nf as polmod modulo pol2 */
    pol2 = relative_pol(nf_get_pol(nf), emb, pol2);
  }
  if (!last) pol2 = rnfpolredbest(nf, pol2, 0);

  obj_free(rnf);
  pol2 = gerepilecopy(av, pol2);
  if (last) return pol2;
  TB = mkvec2(pol2, gel(TB,2));
  return bnrclassfield_tower(bnr, subgroup, TB, p, finaldeg, absolute, prec);
}

/* subgroups H_i of bnr s.t. bnr/H_i is cyclic and inter_i H_i = subgroup */
static GEN
cyclic_compos(GEN subgroup)
{
  pari_sp av = avma;
  GEN U, L, pe, D = smithclean( ZM_snfall_i(subgroup, &U, NULL, 1) );
  long i, l = lg(D);

  L = cgetg(l, t_VEC);
  if (l == 1) return L;
  pe = gel(D,1); U = matinvmod(U, pe);
  for (i = 1; i < l; i++)
    gel(L,i) = hnfmodid(shallowconcat(subgroup, vecsplice(U,i)),pe);
  return gerepilecopy(av, L);
}

/* set kum=NULL if roots of unity already in base field */
/* absolute=1 allowed if extension is cyclic with exponent>1 */
static GEN
bnrclassfield_primepower(struct rnfkummer *ptkum, GEN bnr, GEN subgroup, GEN p,
  GEN P, long absolute, long prec)
{
  GEN res, subs = cyclic_compos(subgroup);
  long i, l = lg(subs);

  res = cgetg(l,t_VEC);
  for (i = 1; i < l; i++)
  {
    GEN H = gel(subs,i), cnd = bnrconductor_i(bnr, hnfmodid(H,p), 2);
    GEN pol, pe, bnr2 = gel(cnd,2), Hp = gel(cnd,3);
    if (ptkum)  pol = rnfkummer_ell(ptkum, bnr2, Hp, 0);
    else        pol = rnfkummersimple(bnr2, Hp, itos(p), 0);
    pe = ZM_det_triangular(H);
    if (!equalii(p,pe))
      pol = bnrclassfield_tower(bnr, H, mkvec2(pol,P), p, itos(pe), absolute, prec);
    gel(res,i) = pol;
  }
  return res;
}

static void
bnrclassfield_sanitize(GEN *pbnr, GEN *pH)
{
  GEN cyc, cnd, bnr = *pbnr, H = *pH;
  if (nftyp(bnr)==typ_BNF) bnr = bnrinit0(bnr, gen_1, 0); else checkbnr(bnr);
  cyc = bnr_get_cyc(bnr);
  if (!H) H = gen_0;
  switch(typ(H))
  {
    case t_INT: H = scalarmat_shallow(H, lg(cyc)-1);
    case t_MAT: H = hnfmodid(H, cyc); break;
    default: pari_err_TYPE("bnrclassfield [subgroup]", H);
  }
  cnd = bnrconductor_i(bnr, H, 2);
  *pbnr = gel(cnd,2);
  *pH = gel(cnd,3);
}

/* partition of v into two subsets whose products are as balanced as possible */
/* assume v sorted */
static GEN
vecsmall_balance(GEN v)
{
  forvec_t T;
  GEN xbounds, x, vuniq, mult, ind, prod, prodbest = gen_0, bound,
      xbest = NULL, res1, res2;
  long i=1, j, k1, k2;
  if (lg(v) == 3) return mkvec2(mkvecsmall(1), mkvecsmall(2));
  vuniq = cgetg(lg(v), t_VECSMALL);
  mult = cgetg(lg(v), t_VECSMALL);
  ind = cgetg(lg(v), t_VECSMALL);
  vuniq[1] = v[1];
  mult[1] = 1;
  ind[1] = 1;
  for (j=2; j<lg(v); j++)
  {
    if (v[j] == vuniq[i]) mult[i]++;
    else
    {
      i++;
      vuniq[i] = v[j];
      mult[i] = 1;
      ind[i] = j;
    }
  }
  setlg(vuniq, ++i);
  setlg(mult, i);
  setlg(ind, i);

  vuniq = zv_to_ZV(vuniq);
  prod = factorback2(vuniq, mult);
  bound = sqrti(prod);
  xbounds = cgetg(lg(mult), t_VEC);
  for (i=1; i<lg(mult); i++) gel(xbounds,i) = mkvec2s(0,mult[i]);

  forvec_init(&T, xbounds, 0);
  while ((x = forvec_next(&T)))
  {
    prod = factorback2(vuniq, x);
    if (cmpii(prod,bound)<=0 && cmpii(prod,prodbest)>0)
    {
      prodbest = prod;
      xbest = gcopy(x);
    }
  }
  res1 = cgetg(lg(v), t_VECSMALL);
  res2 = cgetg(lg(v), t_VECSMALL);
  for (i=1,k1=1,k2=1; i<lg(xbest); i++)
  {
    for (j=0; j<itos(gel(xbest,i)); j++) res1[k1++] = ind[i]+j;
    for (; j<mult[i]; j++)               res2[k2++] = ind[i]+j;
  }
  setlg(res1, k1);
  setlg(res2, k2); return mkvec2(res1, res2);
}

/* TODO nfcompositum should accept vectors of pols */
/* assume all fields are linearly disjoint */
/* assume the polynomials are sorted by degree */
static GEN
nfcompositumall(GEN nf, GEN L)
{
  GEN pol, vdeg, part;
  long i;
  if (lg(L)==2) return gel(L,1);
  vdeg = cgetg(lg(L), t_VECSMALL);
  for (i=1; i<lg(L); i++) vdeg[i] = degree(gel(L,i));
  part = vecsmall_balance(vdeg);
  pol = cgetg(3, t_VEC);
  for (i = 1; i < 3; i++)
  {
    GEN L2 = vecpermute(L, gel(part,i)), T = nfcompositumall(nf, L2);
    gel(pol,i) = rnfpolredbest(nf, T, 0);
  }
  return nfcompositum(nf, gel(pol,1), gel(pol,2), 2);
}

/* flag:
 * 0 list of polynomials whose compositum is the extension
 * 1 single polynomial
 * 2 single absolute polynomial */
GEN
bnrclassfield(GEN bnr, GEN subgroup, long flag, long prec)
{
  pari_sp av = avma;
  GEN N, fa, res, bnf, nf, P, PN, Pmod, EN;
  long i, absolute, lPN;
  struct rnfkummer kum;
  if (flag<0 || flag>2) pari_err_FLAG("bnrclassfield [must be 0,1 or 2]");
  bnrclassfield_sanitize(&bnr, &subgroup);

  N = ZM_det_triangular(subgroup);
  if (equali1(N)) { set_avma(av); return pol_x(0); }
  fa = Z_factor(N);
  PN = gel(fa,1); lPN = lg(PN);
  EN = gel(fa,2);
  if (lgefint(gel(PN,lPN-1)) > 3)
    pari_err_OVERFLOW("bnrclassfield [extension of too large degree]");
  bnf = bnr_get_bnf(bnr);
  nf = bnf_get_nf(bnf);

  /* one prime, exponent > 1 */
  absolute = flag==2 && lPN==2 && !equali1(gel(EN,1));

  Pmod = leafcopy(gel(bid_get_fact(bnr_get_bid(bnr)),1));
  for (i=1; i<lg(Pmod); i++) gel(Pmod,i) = pr_get_p(gel(Pmod,i));
  settyp(Pmod, t_VEC);
  P = ZV_sort_uniq(shallowconcat(nf_get_ramified_primes(nf), Pmod));

  res = cgetg(lPN, t_VEC);
  for (i = 1; i < lPN; i++)
  {
    struct rnfkummer *pkum = NULL;
    GEN p = gel(PN,i), H = hnfmodid(subgroup, powii(p, gel(EN,i)));
    long sp = itos(p);
    absolute &= (lg(H)==2 || equali1(gcoeff(H,2,2))); /* cyclic */
    if (bnf_get_tuN(bnf) % sp)
    {
      pkum = &kum;
      rnfkummer_init(pkum, bnf, sp, prec);
    }
    gel(res,i) = bnrclassfield_primepower(pkum, bnr, H, p, P, absolute, prec);
  }
  res = liftpol_shallow(shallowconcat1(res));
  res = gen_sort(res, (void*)cmp_RgX, gen_cmp_RgX);
  if (flag)
  {
    res = nfcompositumall(nf, res);
    if (flag==2 && !absolute) res = rnfequation(nf, res);
  }
  return gerepileupto(av,res);
}
