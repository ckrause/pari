/* Copyright (C) 2000  The PARI group.

This file is part of the PARI/GP package.

PARI/GP is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation. It is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY WHATSOEVER.

Check the License for details. You should have received a copy of it, along
with the package; see the file 'COPYING'. If not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */

/*******************************************************************/
/*                                                                 */
/*                      KUMMER EXTENSIONS                          */
/*                                                                 */
/*******************************************************************/
#include "pari.h"
#include "paripriv.h"

typedef struct {
  GEN R; /* nf.pol */
  GEN x; /* tau ( Mod(x, R) ) */
  GEN zk;/* action of tau on nf.zk (as t_MAT) */
} tau_s;

typedef struct {
  GEN polnf, invexpoteta1, powg;
  tau_s *tau;
  long m;
} toK_s;

typedef struct {
  GEN R; /* ZX, compositum(P,Q) */
  GEN p; /* QX, Mod(p,R) root of P */
  GEN q; /* QX, Mod(q,R) root of Q */
  long k; /* Q[X]/R generated by q + k p */
  GEN rev;
} compo_s;

static long
prank(GEN cyc, long ell)
{
  long i, l = lg(cyc);
  for (i=1; i < l; i++)
    if (umodiu(gel(cyc,i),ell)) break;
  return i-1;
}

/* increment y, which runs through [0,d-1]^(k-1). Return 0 when done. */
static int
increment(GEN y, long k, long d)
{
  long i = k, j;
  do
  {
    if (--i == 0) return 0;
    y[i]++;
  } while (y[i] >= d);
  for (j = i+1; j < k; j++) y[j] = 0;
  return 1;
}

static int
ok_congruence(GEN X, ulong ell, long lW, GEN vecMsup)
{
  long i, l;
  l = lg(X);
  for (i=lW; i<l; i++)
    if (X[i] == 0) return 0;
  if (lW >= l && zv_equal0(X)) return 0;
  l = lg(vecMsup);
  for (i=1; i<l; i++)
    if (zv_equal0(Flm_Flc_mul(gel(vecMsup,i),X, ell))) return 0;
  return 1;
}

static int
ok_sign(GEN X, GEN msign, GEN arch)
{
  return zv_equal(Flm_Flc_mul(msign, X, 2), arch);
}

/* REDUCTION MOD ell-TH POWERS */

/* make be integral by multiplying by t in (Q^*)^ell */
static GEN
reduce_mod_Qell(GEN bnfz, GEN be, GEN gell)
{
  GEN c;
  be = nf_to_scalar_or_basis(bnfz, be);
  be = Q_primitive_part(be, &c);
  if (c)
  {
    GEN d, fa = factor(c);
    gel(fa,2) = FpC_red(gel(fa,2), gell);
    d = factorback(fa);
    be = typ(be) == t_INT? mulii(be,d): ZC_Z_mul(be, d);
  }
  return be;
}

/* return q, q^n r = x, v_pr(r) < n for all pr */
static GEN
idealsqrtn(GEN nf, GEN x, GEN gn)
{
  long i, l, n = itos(gn);
  GEN fa, q, Ex, Pr;

  fa = idealfactor(nf, x);
  Pr = gel(fa,1); l = lg(Pr);
  Ex = gel(fa,2); q = NULL;
  for (i=1; i<l; i++)
  {
    long ex = itos(gel(Ex,i));
    GEN e = stoi(ex / n);
    if (q) q = idealmulpowprime(nf, q, gel(Pr,i), e);
    else   q = idealpow(nf, gel(Pr,i), e);
  }
  return q? q: gen_1;
}

static GEN
reducebeta(GEN bnfz, GEN b, GEN ell)
{
  GEN y, cb, fu, nf = bnf_get_nf(bnfz);

  if (DEBUGLEVEL>1) err_printf("reducing beta = %Ps\n",b);
  b = reduce_mod_Qell(nf, b, ell);
  /* reduce l-th root */
  y = idealsqrtn(nf, b, ell); /* (b) = y^ell I, I integral */
  if (typ(y) == t_MAT && !is_pm1(gcoeff(y,1,1)))
  {
    GEN T = idealred(nf, mkvec2(y, gen_1)), t = gel(T,2);
    /* (t)*T[1] = y, T[1] integral and small */
    if (gcmp(idealnorm(nf,t), gen_1) > 0)
      b = nfmul(nf, b, nfpow(nf, t, negi(ell)));
  }
  if (DEBUGLEVEL>1) err_printf("beta reduced via ell-th root = %Ps\n",b);
  b = Q_primitive_part(b, &cb);
  if (cb)
  {
    y = nfroots(nf, gsub(monomial(gen_1, itou(ell), fetch_var_higher()),
                         basistoalg(nf,b)));
    delete_var();
  }
  if (cb && lg(y) != 1) b = cb;
  else if ((fu = bnf_build_cheapfu(bnfz)))
  { /* log. embeddings of fu^ell */
    GEN logfu = bnf_get_logfu(bnfz);
    GEN elllogfu = RgM_Rg_mul(real_i(logfu), ell);
    long prec = nf_get_prec(nf);
    for (;;)
    {
      GEN ex, z = nflogembed(nf, b, NULL, prec);
      if (z)
      {
        ex = RgM_Babai(elllogfu, z);
        if (ex)
        {
          if (ZV_equal0(ex)) break;
          y = nffactorback(nf, fu, RgC_Rg_mul(ex,ell));
          b = nfdiv(nf, b, y); break;
        }
      }
      prec = precdbl(prec);
      if (DEBUGLEVEL) pari_warn(warnprec,"reducebeta",prec);
      nf = nfnewprec_shallow(nf,prec);
    }
    if (cb) b = gmul(b, cb);
  }
  if (DEBUGLEVEL>1) err_printf("beta LLL-reduced mod U^l = %Ps\n",b);
  return b;
}

/* FIXME: remove */
static GEN
tauofalg(GEN x, tau_s *tau) {
  long tx = typ(x);
  if (tx == t_POLMOD) { x = gel(x,2); tx = typ(x); }
  if (tx == t_POL) x = RgX_RgXQ_eval(x, tau->x, tau->R);
  return mkpolmod(x, tau->R);
}

struct rnfkummer
{
  GEN bnfz, u, vecC, Q, vecW;
  ulong g, ell;
  long rc;
  compo_s COMPO;
  tau_s tau;
  toK_s T;
};

/* set kum->tau; compute Gal(K(\zeta_l)/K) */
static void
get_tau(struct rnfkummer *kum)
{ /* compute action of tau: q^g + kp */
  compo_s *C = &kum->COMPO;
  GEN U = RgX_add(RgXQ_powu(C->q, kum->g, C->R), RgX_muls(C->p, C->k));
  kum->tau.x  = RgX_RgXQ_eval(C->rev, U, C->R);
  kum->tau.R  = C->R;
  kum->tau.zk = nfgaloismatrix(bnf_get_nf(kum->bnfz), kum->tau.x);
}

static GEN tauoffamat(GEN x, tau_s *tau);

static GEN
tauofelt(GEN x, tau_s *tau)
{
  switch(typ(x))
  {
    case t_COL: return RgM_RgC_mul(tau->zk, x);
    case t_MAT: return tauoffamat(x, tau);
    default: return tauofalg(x, tau);
  }
}
static GEN
tauofvec(GEN x, tau_s *tau)
{
  long i, l;
  GEN y = cgetg_copy(x, &l);
  for (i=1; i<l; i++) gel(y,i) = tauofelt(gel(x,i), tau);
  return y;
}
/* [x, tau(x), ..., tau^(m-1)(x)] */
static GEN
powtau(GEN x, long m, tau_s *tau)
{
  GEN y = cgetg(m+1, t_VEC);
  long i;
  gel(y,1) = x;
  for (i=2; i<=m; i++) gel(y,i) = tauofelt(gel(y,i-1), tau);
  return y;
}
/* x^lambda */
static GEN
lambdaofelt(GEN x, toK_s *T)
{
  tau_s *tau = T->tau;
  long i, m = T->m;
  GEN y = trivial_fact(), powg = T->powg; /* powg[i] = g^i */
  for (i=1; i<m; i++)
  {
    y = famat_mulpows_shallow(y, x, uel(powg,m-i+1));
    x = tauofelt(x, tau);
  }
  return famat_mul_shallow(y, x);
}
static GEN
lambdaofvec(GEN x, toK_s *T)
{
  long i, l;
  GEN y = cgetg_copy(x, &l);
  for (i=1; i<l; i++) gel(y,i) = lambdaofelt(gel(x,i), T);
  return y;
}

static GEN
tauoffamat(GEN x, tau_s *tau)
{
  return mkmat2(tauofvec(gel(x,1), tau), gel(x,2));
}

static GEN
tauofideal(GEN id, tau_s *tau)
{
  return ZM_hnfmodid(RgM_mul(tau->zk, id), gcoeff(id, 1,1));
}

static int
isprimeidealconj(GEN P, GEN Q, tau_s *tau)
{
  GEN p = pr_get_p(P);
  GEN x = pr_get_gen(P);
  if (!equalii(p, pr_get_p(Q))
   || pr_get_e(P) != pr_get_e(Q)
   || pr_get_f(P) != pr_get_f(Q)) return 0;
  if (ZV_equal(x, pr_get_gen(Q))) return 1;
  for(;;)
  {
    if (ZC_prdvd(x,Q)) return 1;
    x = FpC_red(tauofelt(x, tau), p);
    if (ZC_prdvd(x,P)) return 0;
  }
}

static int
isconjinprimelist(GEN S, GEN pr, tau_s *tau)
{
  long i, l;

  if (!tau) return 0;
  l = lg(S);
  for (i=1; i<l; i++)
    if (isprimeidealconj(gel(S,i),pr,tau)) return 1;
  return 0;
}

/* assume x in basistoalg form */
static GEN
downtoK(toK_s *T, GEN x)
{
  long degKz = lg(T->invexpoteta1) - 1;
  GEN y = gmul(T->invexpoteta1, Rg_to_RgC(lift_shallow(x), degKz));
  return gmodulo(gtopolyrev(y,varn(T->polnf)), T->polnf);
}

static void
no_sol(long i) { pari_err_BUG(stack_sprintf("kummer [bug%ld]", i)); }

static GEN
get_gell(GEN bnr, GEN subgp)
{
  if (!subgp) return ZV_prod(bnr_get_cyc(bnr));
  return det(subgp);
}

typedef struct {
  GEN Sm, Sml1, Sml2, Sl, ESml2;
} primlist;

static int
build_list_Hecke(primlist *L, GEN nfz, GEN fa, GEN gothf, long ell, tau_s *tau)
{
  GEN listpr, listex, pr, factell;
  long vp, i, l, degKz = nf_get_degree(nfz);

  if (!fa) fa = idealfactor(nfz, gothf);
  listpr = gel(fa,1);
  listex = gel(fa,2); l = lg(listpr);
  L->Sm  = vectrunc_init(l);
  L->Sml1= vectrunc_init(l);
  L->Sml2= vectrunc_init(l);
  L->Sl  = vectrunc_init(l+degKz);
  L->ESml2=vecsmalltrunc_init(l);
  for (i=1; i<l; i++)
  {
    pr = gel(listpr,i);
    vp = itos(gel(listex,i));
    if (!equaliu(pr_get_p(pr), ell))
    {
      if (vp != 1) return 1;
      if (!isconjinprimelist(L->Sm,pr,tau)) vectrunc_append(L->Sm,pr);
    }
    else
    {
      long e = pr_get_e(pr), vd = (vp-1)*(ell-1)-ell*e;
      if (vd > 0) return 4;
      if (vd==0)
      {
        if (!isconjinprimelist(L->Sml1,pr,tau)) vectrunc_append(L->Sml1, pr);
      }
      else
      {
        if (vp==1) return 2;
        if (!isconjinprimelist(L->Sml2,pr,tau))
        {
          vectrunc_append(L->Sml2, pr);
          vecsmalltrunc_append(L->ESml2, vp);
        }
      }
    }
  }
  factell = idealprimedec(nfz,utoipos(ell)); l = lg(factell);
  for (i=1; i<l; i++)
  {
    pr = gel(factell,i);
    if (!idealval(nfz,gothf,pr) && !isconjinprimelist(L->Sl,pr,tau))
      vectrunc_append(L->Sl, pr);
  }
  return 0; /* OK */
}

/* Return a Flm */
static GEN
logall(GEN nf, GEN vec, long lW, long mginv, long ell, GEN pr, long ex)
{
  pari_sp av = avma;
  GEN m, M, sprk = log_prk_init(nf, pr, ex);
  long ellrank, i, l = lg(vec);

  ellrank = prank(gel(sprk,1), ell);
  M = cgetg(l,t_MAT);
  for (i=1; i<l; i++)
  {
    m = log_prk(nf, gel(vec,i), sprk, utoi(ell));
    setlg(m, ellrank+1);
    if (i < lW) m = gmulsg(mginv, m);
    gel(M,i) = ZV_to_Flv(m, ell);
  }
  return gerepilecopy(av, M);
}

/* compute the u_j (see remark 5.2.15.) */
static GEN
get_u(GEN cyc, long rc, ulong ell)
{
  long i, l = lg(cyc);
  GEN u = cgetg(l,t_VECSMALL);
  for (i=1; i<=rc; i++) uel(u,i) = 0;
  for (   ; i < l; i++) uel(u,i) = Fl_inv(umodiu(gel(cyc,i), ell), ell);
  return u;
}

/* alg. 5.2.15. with remark */
static void
isprincipalell(GEN bnfz, GEN id, GEN cycgen, GEN u, ulong ell, long rc,
               GEN *pv, GEN *pb)
{
  long i, l = lg(cycgen);
  GEN v, b, db, y = bnfisprincipal0(bnfz, id, nf_FORCE|nf_GENMAT);

  v = ZV_to_Flv(gel(y,1), ell);
  b = gel(y,2);
  if (typ(b) == t_COL)
  {
    b = Q_remove_denom(gel(y,2), &db);
    if (db) b = famat_mulpows_shallow(b, db, -1);
  }
  for (i = rc+1; i < l; i++)
  {
    ulong e = Fl_mul( uel(v,i), uel(u,i), ell);
    b = famat_mulpows_shallow(b, gel(cycgen,i), e);
  }
  setlg(v,rc+1); *pv = v; *pb = b;
}

static GEN
compute_beta(GEN X, GEN vecWB, GEN ell, GEN bnfz)
{
  GEN BE, be;
  BE = famat_reduce(famatV_zv_factorback(vecWB, X));
  gel(BE,2) = centermod(gel(BE,2), ell);
  be = nffactorback(bnfz, BE, NULL);
  be = reducebeta(bnfz, be, ell);
  if (DEBUGLEVEL>1) err_printf("beta reduced = %Ps\n",be);
  return be;
}

static GEN
futu(GEN bnf)
{
  GEN fu, tu, SUnits = bnf_get_sunits(bnf);
  if (SUnits)
  {
    tu = nf_to_scalar_or_basis(bnf_get_nf(bnf), bnf_get_tuU(bnf));
    fu = bnf_compactfu(bnf);
  }
  else
  {
    GEN U = bnf_build_units(bnf);
    tu = gel(U,1); fu = vecslice(U, 2, lg(U)-1);
  }
  return vec_append(fu, tu);
}
static GEN
get_Selmer(GEN bnf, GEN cycgen, long rc)
{ return shallowconcat(futu(bnf), vecslice(cycgen,1,rc)); }

GEN
lift_if_rational(GEN x)
{
  long lx, i;
  GEN y;

  switch(typ(x))
  {
    default: break;

    case t_POLMOD:
      y = gel(x,2);
      if (typ(y) == t_POL)
      {
        long d = degpol(y);
        if (d > 0) return x;
        return (d < 0)? gen_0: gel(y,2);
      }
      return y;

    case t_POL: lx = lg(x);
      for (i=2; i<lx; i++) gel(x,i) = lift_if_rational(gel(x,i));
      break;
    case t_VEC: case t_COL: case t_MAT: lx = lg(x);
      for (i=1; i<lx; i++) gel(x,i) = lift_if_rational(gel(x,i));
  }
  return x;
}

/* lift elt t in nf to nfz, algebraic form */
static GEN
lifttoKz(GEN nf, GEN t, compo_s *C)
{
  GEN x = nf_to_scalar_or_alg(nf, t);
  if (typ(x) != t_POL) return x;
  return RgX_RgXQ_eval(x, C->p, C->R);
}
/* lift ideal id in nf to nfz */
static GEN
ideallifttoKz(GEN nfz, GEN nf, GEN id, compo_s *C)
{
  GEN I = idealtwoelt(nf,id);
  GEN x = nf_to_scalar_or_alg(nf, gel(I,2));
  if (typ(x) != t_POL) return gel(I,1);
  gel(I,2) = algtobasis(nfz, RgX_RgXQ_eval(x, C->p, C->R));
  return idealhnf_two(nfz,I);
}

static GEN
prlifttoKz_i(GEN nfz, GEN nf, GEN pr, compo_s *C)
{
  GEN p = pr_get_p(pr), T = nf_get_pol(nfz);
  if (nf_get_degree(nf) != 1)
  { /* restrict to primes above pr */
    GEN t = pr_get_gen(pr);
    t = Q_primpart( lifttoKz(nf,t,C) );
    T = FpX_gcd(FpX_red(T,p), FpX_red(t,p), p);
    T = FpX_normalize(T, p);
  }
  return gel(FpX_factor(T, p), 1);
}
/* lift ideal pr in nf to ONE prime in nfz (the others are conjugate under tau
 * and bring no further information on e_1 W). Assume pr coprime to
 * index of both nf and nfz, and unramified in Kz/K (minor simplification) */
static GEN
prlifttoKz(GEN nfz, GEN nf, GEN pr, compo_s *C)
{
  GEN P = prlifttoKz_i(nfz, nf, pr, C);
  return idealprimedec_kummer(nfz, gel(P,1), pr_get_e(pr), pr_get_p(pr));
}
static GEN
prlifttoKzall(GEN nfz, GEN nf, GEN pr, compo_s *C)
{
  GEN P = prlifttoKz_i(nfz, nf, pr, C), p = pr_get_p(pr), vP;
  long l = lg(P), e = pr_get_e(pr), i;
  vP = cgetg(l, t_VEC);
  for (i = 1; i < l; i++)
    gel(vP,i) = idealprimedec_kummer(nfz,gel(P,i), e, p);
  return vP;
}

static GEN
get_badbnf(GEN bnf)
{
  long i, l;
  GEN bad = gen_1, gen = bnf_get_gen(bnf);
  l = lg(gen);
  for (i = 1; i < l; i++)
  {
    GEN g = gel(gen,i);
    bad = lcmii(bad, gcoeff(g,1,1));
  }
  return bad;
}
/* test whether H has index p */
static int
H_is_good(GEN H, GEN p)
{
  long l = lg(H), status = 0, i;
  for (i = 1; i < l; i++)
    if (equalii(gcoeff(H,i,i), p) && ++status > 1) return 0;
  return status == 1;
}
/* Let K base field, L/K described by bnr (conductor F) + H. Return a list of
 * primes coprime to f*ell of degree 1 in K whose images in Cl_f(K) together
 * with ell*Cl_f(K), generate H:
 * thus they all split in Lz/Kz; t in Kz is such that
 * t^(1/p) generates Lz => t is an ell-th power in k(pr) for all such primes.
 * Restrict to primes not dividing
 * - the index of the polynomial defining Kz,
 * - the modulus,
 * - ell,
 * - a generator in bnf.gen or bnfz.gen.
 * If ell | F and Kz != K, set compute the congruence group Hz over Kz
 * and set *Fz to the conductor. */
static GEN
get_prlist(GEN bnr, GEN H, ulong ell, GEN *Fz, struct rnfkummer *kum)
{
  pari_sp av0 = avma;
  GEN gell = utoipos(ell), Hz = NULL, bnrz = NULL, cycz = NULL, nfz = NULL;
  GEN cyc = bnr_get_cyc(bnr), nf = bnr_get_nf(bnr), F = gel(bnr_get_mod(bnr),1);
  GEN bad, Hsofar, L = cgetg(1, t_VEC);
  forprime_t T;
  ulong p;
  int Ldone = 0;

  bad = get_badbnf(bnr_get_bnf(bnr));
  if (kum)
  {
    GEN bnfz = kum->bnfz, ideal = gel(bnr_get_mod(bnr), 1);
    GEN badz = lcmii(get_badbnf(bnfz), nf_get_index(bnf_get_nf(bnfz)));
    bad = lcmii(bad,badz);
    nfz = bnf_get_nf(bnfz);
    *Fz = ideallifttoKz(nfz, nf, ideal, &kum->COMPO);
    if (dvdiu(gcoeff(ideal,1,1), ell))
    { /* ell | N(ideal), need Hz = Ker N: Cl_Kz(bothz) -> Cl_K(ideal)/H
       * to update conductor */
      bnrz = Buchraymod(bnfz, *Fz, nf_INIT, gell);
      cycz = bnr_get_cyc(bnrz);
      Hz = diagonal_shallow(ZV_gcdmod(cycz, gell));
      if (H_is_good(Hz, gell))
      {
        *Fz = bnrconductormod(bnrz, Hz, 0, gell);
        gerepileall(av0, 2, &L, Fz); return L;
      }
    }
  }
  bad = lcmii(gcoeff(F,1,1), bad);
  cyc = ZV_gcdmod(cyc, gell);
  Hsofar = diagonal_shallow(cyc);
  if (H_is_good(Hsofar, gell))
  {
    Ldone = 1;
    if (!Hz) { gerepileall(av0, Fz? 2: 1, &L, Fz); return L; }
  }
  /* restrict to primes not dividing bad and 1 mod ell */
  u_forprime_arith_init(&T, 2, ULONG_MAX, 1, ell);
  while ((p = u_forprime_next(&T)))
  {
    GEN LP;
    long i, l;
    if (!umodiu(bad, p)) continue;
    LP = idealprimedec_limit_f(nf, utoipos(p), 1);
    l = lg(LP);
    for (i = 1; i < l; i++)
    {
      pari_sp av = avma;
      GEN M, P = gel(LP,i), v = bnrisprincipalmod(bnr, P, gell, 0);
      if (!hnf_invimage(H, v)) { set_avma(av); continue; }
      /* P in H */
      M = ZM_hnfmodid(shallowconcat(Hsofar, v), cyc);
      if (Hz)
      { /* N_{Kz/K} P in H hence P in Hz */
        GEN vP = prlifttoKzall(nfz, nf, P, &kum->COMPO);
        long j, lv = lg(vP);
        for (j = 1; j < lv; j++)
        {
          v = bnrisprincipalmod(bnrz, gel(vP,j), gell, 0);
          if (!ZV_equal0(v))
          {
            Hz = ZM_hnfmodid(shallowconcat(Hz,v), cycz);
            if (H_is_good(Hz, gell))
            {
              *Fz = bnrconductormod(bnrz, Hz, 0, gell);
              L = vec_append(L, gel(vP,1));
              gerepileall(av0, 2, &L, Fz); return L;
            }
          }
        }
        P = gel(vP,1);
      }
      else if (kum) P = prlifttoKz(nfz, nf, P, &kum->COMPO);
      if (Ldone || ZM_equal(M, Hsofar)) continue;
      L = vec_append(L, P);
      Hsofar = M;
      if (H_is_good(Hsofar, gell))
      {
        Ldone = 1;
        if (!Hz) { gerepileall(av0, Fz? 2: 1, &L, Fz); return L; }
      }
    }
  }
  pari_err_BUG("rnfkummer [get_prlist]");
  return NULL;/*LCOV_EXCL_LINE*/
}
/*Lprz list of prime ideals in Kz that must split completely in Lz/Kz, vecWA
 * generators for the S-units used to build the Kummer generators. Return
 * matsmall M such that \prod WA[j]^x[j] ell-th power mod pr[i] iff
 * \sum M[i,j] x[j] = 0 (mod ell) */
static GEN
subgroup_info(GEN bnfz, GEN Lprz, long ell, GEN vecWA)
{
  GEN nfz = bnf_get_nf(bnfz), M, gell = utoipos(ell), Lell = mkvec(gell);
  long i, j, l = lg(vecWA), lz = lg(Lprz);
  M = cgetg(l, t_MAT);
  for (j=1; j<l; j++) gel(M,j) = cgetg(lz, t_VECSMALL);
  for (i=1; i < lz; i++)
  {
    GEN pr = gel(Lprz,i), EX = subiu(pr_norm(pr), 1);
    GEN N, g,T,p, prM = idealhnf(nfz, pr);
    GEN modpr = zk_to_Fq_init(nfz, &pr,&T,&p);
    long v = Z_lvalrem(divis(EX,ell), ell, &N) + 1; /* Norm(pr)-1 = N * ell^v */
    GEN ellv = powuu(ell, v);
    g = gener_Fq_local(T,p, Lell);
    g = Fq_pow(g,N, T,p); /* order ell^v */
    for (j=1; j < l; j++)
    {
      GEN logc, c = gel(vecWA,j);
      if (typ(c) == t_MAT) /* famat */
        c = famat_makecoprime(nfz, gel(c,1), gel(c,2), pr, prM, EX);
      c = nf_to_Fq(nfz, c, modpr);
      c = Fq_pow(c, N, T,p);
      logc = Fq_log(c, g, ellv, T,p);
      ucoeff(M, i,j) = umodiu(logc, ell);
    }
  }
  return M;
}

static GEN
rnfkummersimple(GEN bnr, GEN subgroup, long ell)
{
  long i, j, degK, dK, lSml2, lSl2, lSp, rc, lW, prec;
  GEN bnf, nf,bid, ideal, arch, cycgen, cyc, Sp, prSp, matP;
  GEN gell, xell, u, M, K, y, vecMsup, vecW, vecWB, vecBp, msign;
  /* primes landing in subgroup must be totally split */
  GEN Lpr = get_prlist(bnr, subgroup, ell, NULL, NULL);
  primlist L;

  bnf = bnr_get_bnf(bnr); if (!bnf_get_sunits(bnf)) bnf_build_units(bnf);
  nf  = bnf_get_nf(bnf);
  degK = nf_get_degree(nf);

  bid = bnr_get_bid(bnr);
  ideal= bid_get_ideal(bid);
  arch = bid_get_arch(bid); /* this is the conductor */
  i = build_list_Hecke(&L, nf, bid_get_fact2(bid), ideal, ell, NULL);
  if (i) no_sol(i);

  lSml2 = lg(L.Sml2);
  Sp = shallowconcat(L.Sm, L.Sml1); lSp = lg(Sp);
  prSp = shallowconcat(L.Sml2, L.Sl); lSl2 = lg(prSp);

  cycgen = bnf_build_cycgen(bnf);
  cyc = bnf_get_cyc(bnf); rc = prank(cyc, ell);

  vecW = get_Selmer(bnf, cycgen, rc);
  u = get_u(cyc, rc, ell);

  vecBp = cgetg(lSp, t_VEC);
  matP  = cgetg(lSp, t_MAT);
  for (j = 1; j < lSp; j++)
    isprincipalell(bnf,gel(Sp,j), cycgen,u,ell,rc, &gel(matP,j), &gel(vecBp,j));
  vecWB = shallowconcat(vecW, vecBp);

  prec = DEFAULTPREC +
      nbits2extraprec(((degK-1) * (gexpo(vecWB) + gexpo(nf_get_M(nf)))));
  if (nf_get_prec(nf) < prec) nf = nfnewprec_shallow(nf, prec);
  msign = nfsign(nf, vecWB);
  arch = ZV_to_zv(arch);

  vecMsup = cgetg(lSml2,t_VEC);
  M = NULL;
  for (i = 1; i < lSl2; i++)
  {
    GEN pr = gel(prSp,i);
    long e = pr_get_e(pr), z = ell * (e / (ell-1));

    if (i < lSml2)
    {
      z += 1 - L.ESml2[i];
      gel(vecMsup,i) = logall(nf, vecWB, 0,0, ell, pr,z+1);
    }
    M = vconcat(M, logall(nf, vecWB, 0,0, ell, pr,z));
  }
  lW = lg(vecW);
  M = vconcat(M, shallowconcat(zero_Flm(rc,lW-1), matP));
  M = vconcat(M, subgroup_info(bnf, Lpr, ell, vecWB));
  K = Flm_ker(M, ell);
  dK = lg(K)-1;
  y = cgetg(dK+1,t_VECSMALL);
  xell = pol_xn(ell, 0);
  gell = utoipos(ell);
  dK = lg(K)-1;
  while (dK)
  {
    for (i=1; i<dK; i++) y[i] = 0;
    y[i] = 1; /* y = [0,...,0,1,0,...,0], 1 at i'th position */
    do
    {
      pari_sp av = avma;
      GEN X = Flm_Flc_mul(K, y, ell);
      if (ok_congruence(X, ell, lW, vecMsup) && ok_sign(X, msign, arch))
      {/* be satisfies all congruences, x^ell - be is irreducible, signature
        * and relative discriminant are correct */
        GEN P = NULL, be = compute_beta(X, vecWB, gell, bnf);
        be = nf_to_scalar_or_alg(nf, be);
        if (typ(be) == t_POL) be = mkpolmod(be, nf_get_pol(nf));
        P = gsub(xell, be);
        if (dK == 1 ||
            ZM_equal(rnfnormgroup(bnr,P),subgroup)) return P; /*DONE*/
      }
      set_avma(av);
    } while (increment(y, dK, ell));
    y[dK--] = 0;
  }
  return gen_0;
}

static ulong
nf_to_logFl(GEN nf, GEN x, GEN modpr, ulong g, ulong q, ulong ell, ulong p)
{
  x = nf_to_Fp_coprime(nf, x, modpr);
  return Fl_log(Fl_powu(umodiu(x, p), q, p), g, ell, p);
}
static GEN
nfV_to_logFlv(GEN nf, GEN x, GEN modpr, ulong g, ulong q, ulong ell, ulong p)
{ pari_APPLY_long(nf_to_logFl(nf, gel(x,i), modpr, g, q, ell, p)); }

/* Compute e_1 Cl(K)/Cl(K)^ell. If u = w^ell a virtual unit, compute
 * discrete log mod ell on units.gen + bnf.gen (efficient variant of algo
 * 5.3.11) by finding ru degree 1 primes Pj coprime to everything, and gj
 * in k(Pj)^* of order ell such that
 *      log_gj(u_i^((Pj.p - 1) / ell) mod Pj), j = 1..ru
 * has maximal F_ell rank ru then solve linear system */
static GEN
kervirtualunit(struct rnfkummer *kum, GEN vselmer)
{
  GEN bnf = kum->bnfz, cyc = bnf_get_cyc(bnf), nf = bnf_get_nf(bnf);
  GEN B, vy, vz, M, U1, U2, vtau, vell, SUnits = bnf_get_sunits(bnf);
  long i, j, r, l = lg(vselmer), rc = kum->rc, ru = l-1 - rc, ell = kum->ell;
  long LIMC = SUnits? itou(gel(SUnits,4)): 1;
  ulong p;
  forprime_t T;

  vtau = cgetg(l, t_VEC);
  vell = cgetg(l, t_VEC);
  for (j = 1; j < l; j++)
  {
    GEN t = gel(vselmer,j);
    if (typ(t) == t_MAT)
    {
      GEN ct;
      t = nffactorback(bnf, gel(t,1), ZV_to_Flv(gel(t,2), ell));
      t = Q_primitive_part(t, &ct);
      if (ct)
      {
        GEN F = Q_factor(ct);
        ct = factorback2(gel(F,1), ZV_to_Flv(gel(F,2), ell));
        t = (typ(t) == t_INT)? ct: ZC_Z_mul(t, ct);
      }
    }
    gel(vell,j) = t; /* integral, not to far from primitive */
    gel(vtau,j) = tauofelt(t, &kum->tau);
  }
  U1 = vecslice(vell, 1, ru); /* units */
  U2 = vecslice(vell, ru+1, ru+rc); /* cycgen (mod ell-th powers) */
  B = nf_get_index(nf); /* bad primes; from 1 to ru are LIMC-units */
  for (i = 1; i <= rc; i++) B = mulii(B, nfnorm(nf, gel(U2,i)));
  if (LIMC > 1)
  {
    GEN F = absZ_factor_limit(B, LIMC), P = gel(F,1);
    long lP = lg(P);
    B = (lP > 1)? gel(P,lP-1): gen_1;
  }
  vy = cgetg(l, t_MAT);
  for (j = 1; j <= ru; j++) gel(vy,j) = zero_Flv(rc); /* units */
  for (     ; j < l; j++)
  {
    GEN y, w, u = gel(vtau, j); /* virtual unit */
    if (!idealispower(nf, u, ell, &w)) pari_err_BUG("kervirtualunit");
    y = isprincipal(bnf, w); setlg(y, rc+1);
    if (!ZV_equal0(y))
      for (i = 1; i <= rc; i++)
        gel(y,i) = diviiexact(mului(ell,gel(y,i)), gel(cyc,i));
    gel(vy,j) = ZV_to_Flv(y, ell);
  }
  u_forprime_arith_init(&T, LIMC+1, ULONG_MAX, 1, ell);
  M = cgetg(ru+1, t_MAT); r = 1; setlg(M,2);
  vz = cgetg(ru+1, t_MAT);
  while ((p = u_forprime_next(&T))) if (umodiu(B,p))
  {
    GEN P = idealprimedec_limit_f(nf, utoipos(p), 1);
    long nP = lg(P)-1;
    ulong g = rootsof1_Fl(ell, p), q = p / ell; /* (p-1) / ell */
    for (i = 1; i <= nP; i++)
    {
      GEN modpr = zkmodprinit(nf, gel(P,i));
      GEN z, v2;
      gel(M, r) = nfV_to_logFlv(nf, U1, modpr, g, q, ell, p); /* log futu */
      if (Flm_rank(M, ell) < r) continue; /* discard */

      v2 = nfV_to_logFlv(nf, U2, modpr, g, q, ell, p); /* log alpha[1..rc] */
      gel(vz, r) = z = nfV_to_logFlv(nf, vtau, modpr, g, q, ell, p);
      for (j = ru+1; j < l; j++)
        uel(z,j) = Fl_sub(uel(z,j), Flv_dotproduct(v2, gel(vy,j), ell), ell);
      if (r == ru) break;
      r++; setlg(M, r+1);
    }
    if (i < nP) break;
  }
  if (r != ru) pari_err_BUG("kervirtualunit");
  /* Solve prod_k U[k]^x[j,k] = vtau[j] / prod_i alpha[i]^vy[j,i] mod (K^*)^ell
   * for 1 <= j <= #vtau. I.e. for a fixed j: M x[j] = vz[j] (mod ell) */
  M = Flm_inv(Flm_transpose(M), ell);
  vz = Flm_transpose(vz); /* now ru x #vtau */
  for (j = 1; j < l; j++)
    gel(vy,j) = shallowconcat(Flm_Flc_mul(M, gel(vz,j), ell), gel(vy,j));
  return Flm_ker(Flm_Fl_sub(vy, kum->g, ell), ell);
}

static GEN
pol_from_Newton(GEN S)
{
  long i, k, l = lg(S);
  GEN C = cgetg(l+1, t_VEC), c = C + 1;
  gel(c,0) = gen_1;
  gel(c,1) = gel(S,1); /* gen_0 in our case */
  for (k = 2; k < l; k++)
  {
    GEN s = gel(S,k);
    for (i = 2; i < k-1; i++) s = gadd(s, gmul(gel(S,i), gel(c,k-i)));
    gel(c,k) = gdivgs(s, -k);
  }
  return gtopoly(C, 0);
}

/* - mu_b = sum_{0 <= i < m} floor(r_b r_{d-1-i} / ell) tau^i */
static GEN
get_mmu(long b, GEN r, long ell)
{
  long i, m = lg(r)-1;
  GEN M = cgetg(m+1, t_VEC);
  for (i = 0; i < m; i++) gel(M,i+1) = stoi((r[b + 1] * r[m - i]) / ell);
  return M;
}

/* coeffs(x, a..b) in variable v >= varn(x) */
static GEN
split_pol(GEN x, long v, long a, long b)
{
  long i, l = degpol(x);
  GEN y = x + a, z;

  if (l < b) b = l;
  if (a > b || varn(x) != v) return pol_0(v);
  l = b-a + 3;
  z = cgetg(l, t_POL); z[1] = x[1];
  for (i = 2; i < l; i++) gel(z,i) = gel(y,i);
  return normalizepol_lg(z, l);
}

/* return (den_a * z) mod (v^ell - num_a/den_a), assuming deg(z) < 2*ell
 * allow either num/den to be NULL (= 1) */
static GEN
mod_Xell_a(GEN z, long v, long ell, GEN num_a, GEN den_a)
{
  GEN z1 = split_pol(z, v, ell, degpol(z));
  GEN z0 = split_pol(z, v, 0,   ell-1); /* z = v^ell z1 + z0*/
  if (den_a) z0 = gmul(den_a, z0);
  if (num_a) z1 = gmul(num_a, z1);
  return gadd(z0, z1);
}
static GEN
to_alg(GEN nfz, GEN c, long v)
{
  GEN z, D;
  if (typ(c) != t_COL) return c;
  z = gmul(nf_get_zkprimpart(nfz), c);
  if (typ(z) == t_POL) setvarn(z, v);
  D = nf_get_zkden(nfz);
  if (!equali1(D)) z = RgX_Rg_div(z, D);
  return z;
}

/* th. 5.3.5. and prop. 5.3.9. */
static GEN
compute_polrel(struct rnfkummer *kum, GEN be)
{
  toK_s *T = &kum->T;
  long i, k, ell = kum->ell, m = T->m, vT = fetch_var(), vz = fetch_var();
  GEN r, powtaubet, S, p1, root, num_t, den_t, nfzpol, powtau_prim_invbe;
  GEN prim_Rk, C_Rk, prim_root, C_root, prim_invbe, C_invbe;
  GEN nfz = bnf_get_nf(kum->bnfz);
  pari_timer ti;

  r = cgetg(m+1,t_VECSMALL); /* r[i+1] = g^i mod ell */
  r[1] = 1;
  for (i=2; i<=m; i++) r[i] = (r[i-1] * kum->g) % ell;
  powtaubet = powtau(be, m, T->tau);
  if (DEBUGLEVEL>1) { err_printf("Computing Newton sums: "); timer_start(&ti); }
  prim_invbe = Q_primitive_part(nfinv(nfz, be), &C_invbe);
  powtau_prim_invbe = powtau(prim_invbe, m, T->tau);

  root = cgetg(ell + 2, t_POL);
  root[1] = evalsigne(1) | evalvarn(0);
  for (i = 0; i < ell; i++) gel(root,2+i) = gen_0;
  for (i = 0; i < m; i++)
  { /* compute (1/be) ^ (-mu) instead of be^mu [mu << 0].
     * 1/be = C_invbe * prim_invbe */
    GEN mmu = get_mmu(i, r, ell);
    /* p1 = prim_invbe ^ -mu */
    p1 = to_alg(nfz, nffactorback(nfz, powtau_prim_invbe, mmu), vz);
    if (C_invbe) p1 = gmul(p1, powgi(C_invbe, RgV_sumpart(mmu, m)));
    /* root += zeta_ell^{r_i} T^{r_i} be^mu_i */
    gel(root, 2 + r[i+1]) = monomial(p1, r[i+1], vT);
  }
  /* Other roots are as above with z_ell --> z_ell^j.
   * Treat all contents (C_*) and principal parts (prim_*) separately */
  prim_Rk = prim_root = Q_primitive_part(root, &C_root);
  C_Rk = C_root;

  r = vecsmall_reverse(r); /* theta^ell = be^( sum tau^a r_{d-1-a} ) */
  /* Compute modulo X^ell - 1, T^ell - t, nfzpol(vz) */
  p1 = to_alg(nfz, nffactorback(nfz, powtaubet, r), vz);
  num_t = Q_remove_denom(p1, &den_t);

  nfzpol = leafcopy(nf_get_pol(nfz));
  setvarn(nfzpol, vz);
  S = cgetg(ell+1, t_VEC); /* Newton sums */
  gel(S,1) = gen_0;
  for (k = 2; k <= ell; k++)
  { /* compute the k-th Newton sum */
    pari_sp av = avma;
    GEN z, D, Rk = gmul(prim_Rk, prim_root);
    C_Rk = mul_content(C_Rk, C_root);
    Rk = mod_Xell_a(Rk, 0, ell, NULL, NULL); /* mod X^ell - 1 */
    for (i = 2; i < lg(Rk); i++)
    {
      if (typ(gel(Rk,i)) != t_POL) continue;
      z = mod_Xell_a(gel(Rk,i), vT, ell, num_t,den_t); /* mod T^ell - t */
      gel(Rk,i) = RgXQX_red(z, nfzpol); /* mod nfz.pol */
    }
    if (den_t) C_Rk = mul_content(C_Rk, ginv(den_t));
    prim_Rk = Q_primitive_part(Rk, &D);
    C_Rk = mul_content(C_Rk, D); /* root^k = prim_Rk * C_Rk */

    /* Newton sum is ell * constant coeff (in X), which has degree 0 in T */
    z = polcoef_i(prim_Rk, 0, 0);
    z = polcoef_i(z      , 0,vT);
    z = downtoK(T, gmulgs(z, ell));
    if (C_Rk) z = gmul(z, C_Rk);
    gerepileall(av, C_Rk? 3: 2, &z, &prim_Rk, &C_Rk);
    if (DEBUGLEVEL>1) err_printf("%ld(%ld) ", k, timer_delay(&ti));
    gel(S,k) = z;
  }
  if (DEBUGLEVEL>1) err_printf("\n");
  (void)delete_var();
  (void)delete_var(); return pol_from_Newton(S);
}

static void
compositum_red(compo_s *C, GEN P, GEN Q)
{
  GEN p, q, a, z = gel(compositum2(P, Q),1);
  a = gel(z,1);
  p = gel(gel(z,2), 2);
  q = gel(gel(z,3), 2);
  C->k = itos( gel(z,4) );
  /* reduce R. FIXME: should be polredbest(a, 1), but breaks rnfkummer bench */
  z = polredabs0(a, nf_ORIG|nf_PARTIALFACT);
  C->R = gel(z,1);
  a = gel(gel(z,2), 2);
  C->p = RgX_RgXQ_eval(p, a, C->R);
  C->q = RgX_RgXQ_eval(q, a, C->R);
  C->rev = QXQ_reverse(a, C->R);
}

/* replace P->C^(-deg P) P(xC) for the largest integer C such that coefficients
 * remain algebraic integers. Lift *rational* coefficients */
static void
nfX_Z_normalize(GEN nf, GEN P)
{
  long i, l;
  GEN C, Cj, PZ = cgetg_copy(P, &l);
  PZ[1] = P[1];
  for (i = 2; i < l; i++) /* minor variation on RgX_to_nfX (create PZ) */
  {
    GEN z = nf_to_scalar_or_basis(nf, gel(P,i));
    if (typ(z) == t_INT)
      gel(PZ,i) = gel(P,i) = z;
    else
      gel(PZ,i) = ZV_content(z);
  }
  (void)ZX_Z_normalize(PZ, &C);

  if (C == gen_1) return;
  Cj = C;
  for (i = l-2; i > 1; i--)
  {
    if (i != l-2) Cj = mulii(Cj, C);
    gel(P,i) = gdiv(gel(P,i), Cj);
  }
}

/* set kum->vecC, kum->Q */
static void
_rnfkummer_step4(struct rnfkummer *kum, GEN cycgen, long d, long m)
{
  long i, j, rc = kum->rc;
  GEN vecC, vecB = cgetg(rc+1,t_VEC), Tc = cgetg(rc+1,t_MAT);
  GEN gen = bnf_get_gen(kum->bnfz), u = kum->u;
  ulong ell = kum->ell;
  for (j=1; j<=rc; j++)
  {
    GEN p1 = tauofideal(gel(gen,j), &kum->tau);
    isprincipalell(kum->bnfz, p1, cycgen,u,ell,rc, &gel(Tc,j), &gel(vecB,j));
  }

  kum->vecC = vecC = const_vec(rc, trivial_fact());
  if (rc)
  {
    GEN p1 = Flm_powers(Tc, m-2, ell), p2 = vecB;
    for (j = 1; j < m; j++)
    {
      GEN z = Flm_Fl_mul(gel(p1,m-j), Fl_mul(j,d,ell), ell);
      p2 = tauofvec(p2, &kum->tau);
      for (i = 1; i <= rc; i++)
        gel(vecC,i) = famat_mul_shallow(gel(vecC,i),
                                        famatV_zv_factorback(p2, gel(z,i)));
    }
    for (i = 1; i <= rc; i++) gel(vecC,i) = famat_reduce(gel(vecC,i));
  }
  kum->Q = Flm_ker(Flm_Fl_sub(Flm_transpose(Tc), kum->g, ell), ell);
}

static GEN
_rnfkummer_step5(struct rnfkummer *kum, GEN vselmer)
{
  GEN W = kervirtualunit(kum, vselmer);
  long j, l = lg(W);
  for (j = 1; j < l; j++)
    gel(W,j) = famat_reduce(famatV_zv_factorback(vselmer, gel(W,j)));
  settyp(W, t_VEC); return W;
}

static GEN
_rnfkummer_step18(struct rnfkummer *kum, GEN bnr, GEN subgroup, GEN M,
     GEN vecWB, GEN vecMsup)
{
  ulong ell = kum->ell;
  long i, dK, lW = lg(kum->vecW);
  GEN K, y, nf = bnr_get_nf(bnr), gell = utoipos(ell), res = NULL;

  K = Flm_ker(M, ell);
  if (DEBUGLEVEL>2) err_printf("Step 18\n");
  dK = lg(K)-1;
  y = cgetg(dK+1,t_VECSMALL);

  dK = lg(K)-1;
  while (dK)
  {
    for (i=1; i<dK; i++) y[i] = 0;
    y[i] = 1; /* y = [0,...,0,1,0,...,0], 1 at dK'th position */
    do
    { /* cf. algo 5.3.18 */
      GEN X = Flm_Flc_mul(K, y, ell);
      if (ok_congruence(X, ell, lW, vecMsup))
      {
        pari_sp av = avma;
        GEN be = compute_beta(X, vecWB, gell, kum->bnfz);
        GEN P = compute_polrel(kum, be);
        nfX_Z_normalize(nf, P);
        if (DEBUGLEVEL>1) err_printf("polrel(beta) = %Ps\n", P);
        if (dK == 1 ||
            ZM_equal(subgroup, rnfnormgroup(bnr, P))) return P; /* DONE */
        set_avma(av);
      }
    } while (increment(y, dK, ell));
    y[dK--] = 0;
  }
  if (!res) pari_err_BUG("kummer [no solution]");
  return res;
}

/* alg 5.3.5 */
static void
rnfkummer_init(struct rnfkummer *kum, GEN bnf, ulong ell, long prec)
{
  compo_s *COMPO = &kum->COMPO;
  toK_s *T = &kum->T;
  GEN nf  = bnf_get_nf(bnf), polnf = nf_get_pol(nf), vselmer, bnfz, cyc, cycgen;
  long degK, degKz, m, d;
  ulong g;
  pari_timer ti;
  if (DEBUGLEVEL>2) err_printf("Step 1\n");
  if (DEBUGLEVEL) timer_start(&ti);
  compositum_red(COMPO, polnf, polcyclo(ell, varn(polnf)));
  if (DEBUGLEVEL)
  {
    timer_printf(&ti, "[rnfkummer] compositum");
    if (DEBUGLEVEL>1) err_printf("polred(compositum) = %Ps\n",COMPO->R);
  }
  if (DEBUGLEVEL>2) err_printf("Step 2\n");
  degK  = degpol(polnf);
  degKz = degpol(COMPO->R);
  m = degKz / degK;
  d = (ell-1) / m;
  g = Fl_powu(pgener_Fl(ell), d, ell);
  if (Fl_powu(g, m, ell*ell) == 1) g += ell;
  /* ord(g) = m in all (Z/ell^k)^* */
  if (DEBUGLEVEL>2) err_printf("Step 3\n");
  /* could factor disc(R) using th. 2.1.6. */
  kum->bnfz = bnfz = Buchall(COMPO->R, nf_FORCE, maxss(prec,BIGDEFAULTPREC));
  if (DEBUGLEVEL) timer_printf(&ti, "[rnfkummer] bnfinit(Kz)");
  cycgen = bnf_build_cycgen(bnfz);
  cyc = bnf_get_cyc(bnfz);
  kum->ell = ell;
  kum->rc = prank(cyc, ell);
  kum->u = get_u(cyc, kum->rc, ell);
  kum->g = g;

  vselmer = get_Selmer(bnfz, cycgen, kum->rc);
  get_tau(kum);
  if (DEBUGLEVEL>2) err_printf("Step 4\n");
  _rnfkummer_step4(kum, cycgen, d, m);
  if (DEBUGLEVEL>2) err_printf("Step 5\n");
  kum->vecW = _rnfkummer_step5(kum, vselmer);
  if (DEBUGLEVEL>2) err_printf("Step 8\n");
  /* left inverse */
  T->invexpoteta1 = RgM_inv(RgXQ_matrix_pow(COMPO->p, degKz, degK, COMPO->R));
  T->polnf = polnf;
  T->tau = &kum->tau;
  T->m = m;
  T->powg = Fl_powers(g, m, ell);
}

static GEN
rnfkummer_ell(struct rnfkummer *kum, GEN bnr, GEN H)
{
  ulong ell = kum->ell, mginv;
  GEN bnfz = kum->bnfz, nfz = bnf_get_nf(bnfz), cycgen = bnf_build_cycgen(bnfz);
  GEN vecC = kum->vecC, vecW = kum->vecW, u = kum->u, Q = kum->Q;
  long lW = lg(vecW), rc = kum->rc, i, j, lSml2, lSp, lSl2, dc;
  toK_s *T = &kum->T;
  primlist L;
  GEN gothf, Sp, prSp, vecAp, vecBp, matP, vecWA, vecWB, vecMsup, M, lambdaWB;
  /* primes landing in H must be totally split */
  GEN Lpr = get_prlist(bnr, H, ell, &gothf, kum);

  if (DEBUGLEVEL>2) err_printf("Step 9, 10 and 11\n");
  i = build_list_Hecke(&L, nfz, NULL, gothf, ell, T->tau);
  if (i) no_sol(i);

  lSml2 = lg(L.Sml2);
  Sp = shallowconcat(L.Sm, L.Sml1); lSp = lg(Sp);
  prSp = shallowconcat(L.Sml2, L.Sl); lSl2 = lg(prSp);

  if (DEBUGLEVEL>2) err_printf("Step 12\n");
  vecAp = cgetg(lSp, t_VEC);
  vecBp = cgetg(lSp, t_VEC);
  matP  = cgetg(lSp, t_MAT);
  for (j = 1; j < lSp; j++)
  {
    GEN e, a;
    isprincipalell(bnfz, gel(Sp,j), cycgen,u,ell,rc, &e, &a);
    gel(matP,j) = e;
    gel(vecBp,j) = famat_mul_shallow(famatV_zv_factorback(vecC, zv_neg(e)), a);
    gel(vecAp,j) = lambdaofelt(gel(vecBp,j), T);
  }
  if (DEBUGLEVEL>2) err_printf("Step 13\n");
  vecWA = shallowconcat(vecW, vecAp);
  vecWB = shallowconcat(vecW, vecBp);

  if (DEBUGLEVEL>2) err_printf("Step 14, 15 and 17\n");
  mginv = Fl_div(T->m, kum->g, ell);
  vecMsup = cgetg(lSml2,t_VEC);
  M = NULL;
  for (i = 1; i < lSl2; i++)
  {
    GEN pr = gel(prSp,i);
    long e = pr_get_e(pr), z = ell * (e / (ell-1));

    if (i < lSml2)
    {
      z += 1 - L.ESml2[i];
      gel(vecMsup,i) = logall(nfz, vecWA,lW,mginv,ell, pr,z+1);
    }
    M = vconcat(M, logall(nfz, vecWA,lW,mginv,ell, pr,z));
  }
  dc = lg(Q)-1;
  if (dc)
  {
    GEN QtP = Flm_mul(Flm_transpose(Q), matP, ell);
    M = vconcat(M, shallowconcat(zero_Flm(dc,lW-1), QtP));
  }
  if (!M) M = zero_Flm(1, lSp-1 + lW-1);
  lambdaWB = shallowconcat(lambdaofvec(vecW, T), vecAp);/*vecWB^lambda*/
  M = vconcat(M, subgroup_info(bnfz, Lpr, ell, lambdaWB));
  if (DEBUGLEVEL>2) err_printf("Step 16\n");
  return _rnfkummer_step18(kum, bnr, H, M, vecWB, vecMsup);
}

static void
bnrclassfield_sanitize(GEN *pbnr, GEN *pH)
{
  GEN T;
  bnr_subgroup_sanitize(pbnr, pH);
  T = nf_get_pol(bnr_get_nf(*pbnr));
  if (!varn(T)) pari_err_PRIORITY("bnrclassfield", T, "=", 0);
}

static GEN
_rnfkummer(GEN bnr, GEN subgroup, long prec)
{
  ulong ell;
  GEN gell;
  struct rnfkummer kum;

  bnrclassfield_sanitize(&bnr, &subgroup);
  gell = get_gell(bnr,subgroup);
  if (typ(gell) != t_INT) pari_err_TYPE("rnfkummer",gell);
  ell = itou(gell);
  if (ell == 1) return pol_x(0);
  if (!uisprime(ell)) pari_err_IMPL("rnfkummer for composite relative degree");
  if (bnf_get_tuN(bnr_get_bnf(bnr)) % ell == 0)
    return rnfkummersimple(bnr, subgroup, ell);
  rnfkummer_init(&kum, bnr_get_bnf(bnr), ell, prec);
  return rnfkummer_ell(&kum, bnr, subgroup);
}

GEN
rnfkummer(GEN bnr, GEN subgroup, long prec)
{
  pari_sp av = avma;
  return gerepilecopy(av, _rnfkummer(bnr, subgroup, prec));
}

/*******************************************************************/
/*                        bnrclassfield                            */
/*******************************************************************/

/* TODO: could be exported */
static void
gsetvarn(GEN x, long v)
{
  long i;
  switch(typ(x))
  {
    case t_POL: case t_SER:
      setvarn(x, v); return;
    case t_LIST:
      x = list_data(x); if (!x) return;
      /* fall through t_VEC */
    case t_VEC: case t_COL: case t_MAT:
      for (i = lg(x)-1; i > 0; i--) gsetvarn(gel(x,i), v);
  }
}

/* emb root of pol as polmod modulo pol2, return relative polynomial */
static GEN
relative_pol(GEN pol, GEN emb, GEN pol2)
{
  GEN eqn, polrel;
  if (degree(pol)==1) return pol2;
  emb = liftpol(emb);
  eqn = gsub(emb, pol_x(varn(pol)));
  eqn = Q_remove_denom(eqn, NULL);
  polrel = nfgcd(pol2, eqn, pol, NULL);
  return RgX_Rg_div(polrel, leading_coeff(polrel));
}

/* pol defines K/nf */
static GEN
bnrclassfield_tower(GEN bnr, GEN subgroup, GEN TB, GEN p, long finaldeg, long absolute, long prec)
{
  pari_sp av = avma;
  GEN nf, nf2, rnf, bnf, bnf2, bnr2, q, H, dec, cyc, pk, sgpk, pol2, emb, emb2, famod, fa, Lbad, cert;
  long i, r1, ell, sp, spk, last;
  forprime_t iter;

  bnf = bnr_get_bnf(bnr);
  nf = bnf_get_nf(bnf);
  rnf = rnfinit0(nf, TB, 1);
  nf2 = rnf_build_nfabs(rnf, prec);
  gsetvarn(nf2, varn(nf_get_pol(nf)));

  cert = nfcertify(nf2);
  if (lg(cert)>1)
  {
    rnf = rnfinit0(nf, gel(TB,1), 1);
    nf2 = rnf_build_nfabs(rnf, prec);
    gsetvarn(nf2, varn(nf_get_pol(nf)));
  }

  r1 = nf_get_r1(nf2);
  bnf2 = Buchall(nf2, nf_FORCE, prec);

  sp = itos(p);
  spk = sp * rnf_get_degree(rnf);
  pk = stoi(spk);
  sgpk = hnfmodid(subgroup,pk);
  last = spk==finaldeg;

  /* compute conductor */
  famod = gel(bid_get_fact2(bnr_get_bid(bnr)),1);
  if (lg(famod)==1)
  {
    fa = trivial_fact();
    Lbad = cgetg(1, t_VECSMALL);
  }
  else
  {
    long j=1;
    fa = cgetg(3, t_MAT);
    gel(fa,1) = cgetg(lg(famod), t_VEC);
    Lbad = cgetg(lg(famod), t_VEC);
    for(i=1; i<lg(famod); i++)
    {
      GEN pr = gel(famod,i);
      gmael(fa,1,i) = rnfidealprimedec(rnf, pr);
      q = pr_get_p(pr);
      if (lgefint(q) == 3) gel(Lbad,j++) = q;
    }
    setlg(Lbad,j);
    Lbad = ZV_to_zv(ZV_sort_uniq(Lbad));
    gel(fa,1) = shallowconcat1(gel(fa,1));
    settyp(gel(fa,1), t_COL);
    gel(fa,2) = cgetg(lg(gel(fa,1)), t_COL);
    for (i=1; i<lg(gel(fa,1)); i++)
    {
      GEN pr = gcoeff(fa,i,1);
      long e = equalii(p, pr_get_p(pr))? 1 + (pr_get_e(pr)*sp) / (sp-1): 1;
      gcoeff(fa,i,2) = utoipos(e);
    }
  }
  bnr2 = Buchraymod(bnf2, mkvec2(fa, const_vec(r1,gen_1)), nf_INIT, pk);

  /* compute subgroup */
  cyc = bnr_get_cyc(bnr2);
  H = Flm_image(zv_diagonal(ZV_to_Flv(cyc,sp)), sp);
  u_forprime_init(&iter, 2, ULONG_MAX);
  while ((ell = u_forprime_next(&iter))) if (!zv_search(Lbad, ell))
  {
    dec = idealprimedec_limit_f(nf, utoi(ell), 1);
    for (i=1; i<lg(dec); i++)
    {
      GEN pr = gel(dec,i), Pr = gel(rnfidealprimedec(rnf, pr), 1);
      long f = pr_get_f(Pr) / pr_get_f(pr);
      GEN vpr = FpC_Fp_mul(bnrisprincipalmod(bnr,pr,pk,0), utoi(f), pk);
      if (gequal0(ZC_hnfrem(vpr,sgpk)))
        H = vec_append(H, ZV_to_Flv(bnrisprincipalmod(bnr2,Pr,p,0), sp));
    }
    if (lg(H) > lg(cyc)+3)
    {
      H = Flm_image(H, sp);
      if (lg(cyc)-lg(H) == 1) break;
    }
  }
  H = hnfmodid(shallowconcat(zm_to_ZM(H), diagonal_shallow(cyc)), p);

  /* polynomial over nf2 */
  pol2 = _rnfkummer(bnr2, H, prec);
  /* absolute polynomial */
  pol2 = rnfequation2(nf2, pol2);
  emb2 = gel(pol2,2); /* generator of nf2 as polmod modulo pol2 */
  pol2 = gel(pol2,1);
  /* polynomial over nf */
  if (!absolute || !last)
  {
    emb = rnf_get_alpha(rnf); /* generator of nf as polynomial in nf2 */
    emb = poleval(emb, emb2); /* generator of nf as polmod modulo pol2 */
    pol2 = relative_pol(nf_get_pol(nf), emb, pol2);
  }
  if (!last) pol2 = rnfpolredbest(nf, pol2, 0);

  obj_free(rnf);
  pol2 = gerepilecopy(av, pol2);
  if (last) return pol2;
  TB = mkvec2(pol2, gel(TB,2));
  return bnrclassfield_tower(bnr, subgroup, TB, p, finaldeg, absolute, prec);
}

/* subgroups H_i of bnr s.t. bnr/H_i is cyclic and inter_i H_i = subgroup */
static GEN
cyclic_compos(GEN subgroup)
{
  pari_sp av = avma;
  GEN Ui, L, pe, D = ZM_snf_group(subgroup, NULL, &Ui);
  long i, l = lg(D);

  L = cgetg(l, t_VEC);
  if (l == 1) return L;
  pe = gel(D,1);
  for (i = 1; i < l; i++)
    gel(L,i) = hnfmodid(shallowconcat(subgroup, vecsplice(Ui,i)),pe);
  return gerepilecopy(av, L);
}

/* p prime; set pkum=NULL if p-th root of unity in base field
 * absolute=1 allowed if extension is cyclic with exponent>1 */
static GEN
bnrclassfield_primepower(struct rnfkummer *pkum, GEN bnr, GEN subgroup, GEN p,
  GEN P, long absolute, long prec)
{
  GEN res, subs = cyclic_compos(subgroup);
  long i, l = lg(subs);

  res = cgetg(l,t_VEC);
  for (i = 1; i < l; i++)
  {
    GEN H = gel(subs,i), cnd = bnrconductormod(bnr, hnfmodid(H,p), 2, p);
    GEN pol, pe, bnr2 = gel(cnd,2), Hp = gel(cnd,3);
    if (pkum) pol = rnfkummer_ell(pkum, bnr2, Hp);
    else      pol = rnfkummersimple(bnr2, Hp, itos(p));
    pe = ZM_det_triangular(H);
    if (!equalii(p,pe))
      pol = bnrclassfield_tower(bnr, H, mkvec2(pol,P), p, itos(pe), absolute, prec);
    gel(res,i) = pol;
  }
  return res;
}

/* partition of v into two subsets whose products are as balanced as possible */
/* assume v sorted */
static GEN
vecsmall_balance(GEN v)
{
  forvec_t T;
  GEN xbounds, x, vuniq, mult, ind, prod, prodbest = gen_0, bound,
      xbest = NULL, res1, res2;
  long i=1, j, k1, k2;
  if (lg(v) == 3) return mkvec2(mkvecsmall(1), mkvecsmall(2));
  vuniq = cgetg(lg(v), t_VECSMALL);
  mult = cgetg(lg(v), t_VECSMALL);
  ind = cgetg(lg(v), t_VECSMALL);
  vuniq[1] = v[1];
  mult[1] = 1;
  ind[1] = 1;
  for (j=2; j<lg(v); j++)
  {
    if (v[j] == vuniq[i]) mult[i]++;
    else
    {
      i++;
      vuniq[i] = v[j];
      mult[i] = 1;
      ind[i] = j;
    }
  }
  setlg(vuniq, ++i);
  setlg(mult, i);
  setlg(ind, i);

  vuniq = zv_to_ZV(vuniq);
  prod = factorback2(vuniq, mult);
  bound = sqrti(prod);
  xbounds = cgetg(lg(mult), t_VEC);
  for (i=1; i<lg(mult); i++) gel(xbounds,i) = mkvec2s(0,mult[i]);

  forvec_init(&T, xbounds, 0);
  while ((x = forvec_next(&T)))
  {
    prod = factorback2(vuniq, x);
    if (cmpii(prod,bound)<=0 && cmpii(prod,prodbest)>0)
    {
      prodbest = prod;
      xbest = gcopy(x);
    }
  }
  res1 = cgetg(lg(v), t_VECSMALL);
  res2 = cgetg(lg(v), t_VECSMALL);
  for (i=1,k1=1,k2=1; i<lg(xbest); i++)
  {
    for (j=0; j<itos(gel(xbest,i)); j++) res1[k1++] = ind[i]+j;
    for (; j<mult[i]; j++)               res2[k2++] = ind[i]+j;
  }
  setlg(res1, k1);
  setlg(res2, k2); return mkvec2(res1, res2);
}

/* TODO nfcompositum should accept vectors of pols */
/* assume all fields are linearly disjoint */
/* assume the polynomials are sorted by degree */
static GEN
nfcompositumall(GEN nf, GEN L)
{
  GEN pol, vdeg, part;
  long i;
  if (lg(L)==2) return gel(L,1);
  vdeg = cgetg(lg(L), t_VECSMALL);
  for (i=1; i<lg(L); i++) vdeg[i] = degree(gel(L,i));
  part = vecsmall_balance(vdeg);
  pol = cgetg(3, t_VEC);
  for (i = 1; i < 3; i++)
  {
    GEN L2 = vecpermute(L, gel(part,i)), T = nfcompositumall(nf, L2);
    gel(pol,i) = rnfpolredbest(nf, T, 0);
  }
  return nfcompositum(nf, gel(pol,1), gel(pol,2), 2);
}

/* flag:
 * 0 list of polynomials whose compositum is the extension
 * 1 single polynomial
 * 2 single absolute polynomial */
GEN
bnrclassfield(GEN bnr, GEN subgroup, long flag, long prec)
{
  pari_sp av = avma;
  GEN N, fa, res, bnf, nf, P, PN, Pmod, EN;
  long i, absolute, lPN;
  struct rnfkummer kum;
  if (flag<0 || flag>2) pari_err_FLAG("bnrclassfield [must be 0,1 or 2]");
  bnrclassfield_sanitize(&bnr, &subgroup);

  N = ZM_det_triangular(subgroup);
  if (equali1(N)) { set_avma(av); return pol_x(0); }
  fa = Z_factor(N);
  PN = gel(fa,1); lPN = lg(PN);
  EN = gel(fa,2);
  if (lgefint(gel(PN,lPN-1)) > 3)
    pari_err_OVERFLOW("bnrclassfield [extension of too large degree]");
  bnf = bnr_get_bnf(bnr);
  nf = bnf_get_nf(bnf);

  /* one prime, exponent > 1 */
  absolute = flag==2 && lPN==2 && !equali1(gel(EN,1));

  Pmod = leafcopy(gel(bid_get_fact(bnr_get_bid(bnr)),1));
  for (i=1; i<lg(Pmod); i++) gel(Pmod,i) = pr_get_p(gel(Pmod,i));
  settyp(Pmod, t_VEC);
  P = ZV_sort_uniq(shallowconcat(nf_get_ramified_primes(nf), Pmod));

  res = cgetg(lPN, t_VEC);
  for (i = 1; i < lPN; i++)
  {
    struct rnfkummer *pkum = NULL;
    GEN p = gel(PN,i), H = hnfmodid(subgroup, powii(p, gel(EN,i)));
    long sp = itos(p);
    if (absolute) absolute = FpM_rank(H,p)==lg(H)-2; /* cyclic */
    if (bnf_get_tuN(bnf) % sp)
    {
      pkum = &kum;
      rnfkummer_init(pkum, bnf, sp, prec);
    }
    gel(res,i) = bnrclassfield_primepower(pkum, bnr, H, p, P, absolute, prec);
  }
  res = liftpol_shallow(shallowconcat1(res));
  res = gen_sort(res, (void*)cmp_RgX, gen_cmp_RgX);
  if (flag)
  {
    res = nfcompositumall(nf, res);
    if (flag==2 && !absolute) res = rnfequation(nf, res);
  }
  return gerepileupto(av,res);
}
